/**
 * Bundle of @devexpress/dx-react-scheduler-material-ui
 * Generated: 2019-09-16
 * Version: 2.0.5
 * License: https://js.devexpress.com/Licensing
 */

'use strict';

if (typeof process === "undefined") { var process = { env: {} }; }

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var React = require('react');
var PropTypes = require('prop-types');
var dxReactScheduler = require('@devexpress/dx-react-scheduler');
var styles$J = require('@material-ui/core/styles');
var dxSchedulerCore = require('@devexpress/dx-scheduler-core');
var classNames = _interopDefault(require('classnames'));
var dxReactCore = require('@devexpress/dx-react-core');
var Grid = _interopDefault(require('@material-ui/core/Grid'));
var colorManipulator = require('@material-ui/core/styles/colorManipulator');
var colors = require('@material-ui/core/colors');
var TableRow = _interopDefault(require('@material-ui/core/TableRow'));
var TableMUI = _interopDefault(require('@material-ui/core/Table'));
var TableBody = _interopDefault(require('@material-ui/core/TableBody'));
var TableCell = _interopDefault(require('@material-ui/core/TableCell'));
var Repeat = _interopDefault(require('@material-ui/icons/Repeat'));
var ToolbarMUI = _interopDefault(require('@material-ui/core/Toolbar'));
var Popover = _interopDefault(require('@material-ui/core/Popover'));
var Button$1 = _interopDefault(require('@material-ui/core/Button'));
var IconButton = _interopDefault(require('@material-ui/core/IconButton'));
var ChevronLeft = _interopDefault(require('@material-ui/icons/ChevronLeft'));
var ChevronRight = _interopDefault(require('@material-ui/icons/ChevronRight'));
var moment = _interopDefault(require('moment'));
var TableHead = _interopDefault(require('@material-ui/core/TableHead'));
var Typography = _interopDefault(require('@material-ui/core/Typography'));
var AccessTime = _interopDefault(require('@material-ui/icons/AccessTime'));
var Fab = _interopDefault(require('@material-ui/core/Fab'));
var EditIcon = _interopDefault(require('@material-ui/icons/Edit'));
var CloseIcon = _interopDefault(require('@material-ui/icons/Close'));
var DeleteIcon = _interopDefault(require('@material-ui/icons/Delete'));
var Select = _interopDefault(require('@material-ui/core/Select'));
var MenuItem = _interopDefault(require('@material-ui/core/MenuItem'));
var OutlinedInput = _interopDefault(require('@material-ui/core/OutlinedInput'));
var Modal = _interopDefault(require('@material-ui/core/Modal'));
var TextField = _interopDefault(require('@material-ui/core/TextField'));
var Checkbox = _interopDefault(require('@material-ui/core/Checkbox'));
var FormControlLabel = _interopDefault(require('@material-ui/core/FormControlLabel'));
var Paper = _interopDefault(require('@material-ui/core/Paper'));
var Dialog = _interopDefault(require('@material-ui/core/Dialog'));
var DialogActions = _interopDefault(require('@material-ui/core/DialogActions'));
var DialogContent = _interopDefault(require('@material-ui/core/DialogContent'));
var DialogTitle = _interopDefault(require('@material-ui/core/DialogTitle'));
var Radio = _interopDefault(require('@material-ui/core/Radio'));
var RadioGroup = _interopDefault(require('@material-ui/core/RadioGroup'));

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys(source, true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(source).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}

function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

function _objectWithoutProperties(source, excluded) {
  if (source == null) return {};

  var target = _objectWithoutPropertiesLoose(source, excluded);

  var key, i;

  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }

  return target;
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _possibleConstructorReturn(self, call) {
  if (call && (typeof call === "object" || typeof call === "function")) {
    return call;
  }

  return _assertThisInitialized(self);
}

function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();
}

function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}

function _iterableToArrayLimit(arr, i) {
  if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) {
    return;
  }

  var _arr = [];
  var _n = true;
  var _d = false;
  var _e = undefined;

  try {
    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance");
}

var ContainerBase = function ContainerBase(_ref) {
  var children = _ref.children,
      classes = _ref.classes,
      className = _ref.className,
      restProps = _objectWithoutProperties(_ref, ["children", "classes", "className"]);

  return React.createElement("div", _extends({
    className: classNames(classes.container, className)
  }, restProps), children);
};
process.env.NODE_ENV !== "production" ? ContainerBase.propTypes = {
  classes: PropTypes.object.isRequired,
  children: PropTypes.node.isRequired,
  className: PropTypes.string
} : void 0;
ContainerBase.defaultProps = {
  className: undefined
};

var styles = {
  container: {
    WebkitOverflowScrolling: 'touch',
    // NOTE: fix sticky positioning in Safari
    width: '100%',
    height: '100%',
    position: 'relative',
    display: 'flex',
    flexDirection: 'column'
  }
};
var LayoutBase = function LayoutBase(_ref) {
  var height = _ref.height,
      style = _ref.style,
      restProps = _objectWithoutProperties(_ref, ["height", "style"]);

  var containerStyle = height === dxSchedulerCore.AUTO_HEIGHT ? {
    height: '100%'
  } : {
    height: "".concat(height, "px")
  };
  return React.createElement(ContainerBase, _extends({
    style: _objectSpread2({}, containerStyle, {}, style)
  }, restProps));
};
process.env.NODE_ENV !== "production" ? LayoutBase.propTypes = {
  height: PropTypes.oneOfType([PropTypes.number, PropTypes.string]).isRequired,
  style: PropTypes.object
} : void 0;
LayoutBase.defaultProps = {
  style: null
};
var Root = styles$J.withStyles(styles, {
  name: 'Root'
})(LayoutBase);

var Scheduler = function Scheduler(_ref) {
  var children = _ref.children,
      restProps = _objectWithoutProperties(_ref, ["children"]);

  return React.createElement(dxReactScheduler.Scheduler, _extends({
    rootComponent: Root
  }, restProps), children);
};
Scheduler.Root = Root;
process.env.NODE_ENV !== "production" ? Scheduler.propTypes = {
  children: PropTypes.node.isRequired
} : void 0;

var PRIMARY_COLOR = colors.blue;

var getBorder = function getBorder(theme) {
  return "1px solid ".concat(theme.palette.type === 'light' ? colorManipulator.lighten(colorManipulator.fade(theme.palette.divider, 1), 0.88) : colorManipulator.darken(colorManipulator.fade(theme.palette.divider, 1), 0.68));
};
var cellsMeta = function cellsMeta(tableElement) {
  var cellElements = Array.from(tableElement.querySelectorAll('td'));
  return {
    parentRect: function parentRect() {
      return tableElement.getBoundingClientRect();
    },
    getCellRects: cellElements.map(function (element) {
      return function () {
        return element.getBoundingClientRect();
      };
    })
  };
};
var scrollingStrategy = function scrollingStrategy(scrollablePart, fixedPart) {
  var fixedPartRect = fixedPart.getBoundingClientRect();

  var changeVerticalScroll = function changeVerticalScroll(value) {
    // eslint-disable-next-line no-param-reassign
    scrollablePart.scrollTop += value;
  };

  return {
    topBoundary: fixedPartRect.height + fixedPartRect.top,
    bottomBoundary: scrollablePart.offsetTop + scrollablePart.clientHeight,
    changeVerticalScroll: changeVerticalScroll
  };
};
var setColor = function setColor(level, color) {
  return color[level] || PRIMARY_COLOR[level];
};

var styles$1 = function styles(theme) {
  return {
    container: {
      overflowY: 'auto',
      position: 'relative'
    },
    stickyHeader: {
      top: 0,
      zIndex: 1,
      tableLayout: 'fixed',
      position: 'sticky',
      overflow: 'visible',
      background: theme.palette.background.paper
    },
    timeTable: {
      position: 'relative'
    }
  };
};

var VerticalViewLayoutBase =
/*#__PURE__*/
function (_React$PureComponent) {
  _inherits(VerticalViewLayoutBase, _React$PureComponent);

  function VerticalViewLayoutBase(props) {
    var _this;

    _classCallCheck(this, VerticalViewLayoutBase);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(VerticalViewLayoutBase).call(this, props));
    _this.layout = React.createRef();
    _this.layoutHeader = React.createRef();
    return _this;
  }

  _createClass(VerticalViewLayoutBase, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      this.setScrollingStrategy();
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate() {
      this.setScrollingStrategy();
    }
  }, {
    key: "setScrollingStrategy",
    value: function setScrollingStrategy() {
      var setScrollingStrategy = this.props.setScrollingStrategy;
      setScrollingStrategy(scrollingStrategy(this.layout.current, this.layoutHeader.current));
    }
  }, {
    key: "render",
    value: function render() {
      var _this$props = this.props,
          TimeScale = _this$props.timeScaleComponent,
          DayScale = _this$props.dayScaleComponent,
          TimeTable = _this$props.timeTableComponent,
          DayScaleEmptyCell = _this$props.dayScaleEmptyCellComponent,
          setScrollingStrategy = _this$props.setScrollingStrategy,
          classes = _this$props.classes,
          className = _this$props.className,
          restProps = _objectWithoutProperties(_this$props, ["timeScaleComponent", "dayScaleComponent", "timeTableComponent", "dayScaleEmptyCellComponent", "setScrollingStrategy", "classes", "className"]);

      return React.createElement(Grid, _extends({
        ref: this.layout,
        container: true,
        className: classNames(classes.container, className),
        direction: "column",
        wrap: "nowrap"
      }, restProps), React.createElement("div", null, React.createElement(Grid, {
        item: true,
        xs: "auto",
        className: classes.stickyHeader
      }, React.createElement(Grid, {
        ref: this.layoutHeader,
        container: true,
        direction: "row"
      }, React.createElement(Grid, {
        item: true,
        xs: 1,
        className: classes.emptySpace
      }, React.createElement(DayScaleEmptyCell, null)), React.createElement(Grid, {
        item: true,
        xs: 11
      }, React.createElement(DayScale, null)))), React.createElement(Grid, {
        item: true,
        xs: "auto"
      }, React.createElement(Grid, {
        container: true,
        direction: "row"
      }, React.createElement(Grid, {
        item: true,
        xs: 1
      }, React.createElement(TimeScale, null)), React.createElement(Grid, {
        item: true,
        xs: 11,
        className: classes.timeTable
      }, React.createElement(TimeTable, null))))));
    }
  }]);

  return VerticalViewLayoutBase;
}(React.PureComponent);

process.env.NODE_ENV !== "production" ? VerticalViewLayoutBase.propTypes = {
  // oneOfType is a workaround because withStyles returns react object
  timeScaleComponent: PropTypes.oneOfType([PropTypes.func, PropTypes.object]).isRequired,
  dayScaleComponent: PropTypes.oneOfType([PropTypes.func, PropTypes.object]).isRequired,
  timeTableComponent: PropTypes.oneOfType([PropTypes.func, PropTypes.object]).isRequired,
  dayScaleEmptyCellComponent: PropTypes.oneOfType([PropTypes.func, PropTypes.object]).isRequired,
  setScrollingStrategy: PropTypes.func.isRequired,
  classes: PropTypes.object.isRequired,
  className: PropTypes.string
} : void 0;
VerticalViewLayoutBase.defaultProps = {
  className: undefined
};
var VerticalViewLayout = styles$J.withStyles(styles$1, {
  name: 'VerticalViewLayout'
})(VerticalViewLayoutBase);

var Row = function Row(_ref) {
  var children = _ref.children,
      restProps = _objectWithoutProperties(_ref, ["children"]);

  return React.createElement(TableRow, restProps, children);
};
process.env.NODE_ENV !== "production" ? Row.propTypes = {
  children: PropTypes.node
} : void 0;
Row.defaultProps = {
  children: null
};

var styles$2 = function styles(theme) {
  return {
    emptyCell: {
      borderBottom: getBorder(theme),
      boxSizing: 'border-box',
      height: '100%',
      width: '100%'
    }
  };
};

var DayScaleEmptyCellBase = function DayScaleEmptyCellBase(_ref) {
  var classes = _ref.classes,
      className = _ref.className,
      children = _ref.children,
      restProps = _objectWithoutProperties(_ref, ["classes", "className", "children"]);

  return React.createElement("div", _extends({}, restProps, {
    className: classNames(classes.emptyCell, className)
  }), children);
};
process.env.NODE_ENV !== "production" ? DayScaleEmptyCellBase.propTypes = {
  classes: PropTypes.object.isRequired,
  className: PropTypes.string,
  children: PropTypes.node
} : void 0;
DayScaleEmptyCellBase.defaultProps = {
  className: undefined,
  children: undefined
};
var DayScaleEmptyCell = styles$J.withStyles(styles$2, {
  name: 'DayScaleEmptyCell'
})(DayScaleEmptyCellBase);

var styles$3 = {
  container: {
    position: 'absolute',
    width: '100%',
    top: 0,
    left: 0
  }
};
var Container = styles$J.withStyles(styles$3, {
  name: 'AppointmentsContainer'
})(ContainerBase);

var styles$4 = {
  table: {
    tableLayout: 'fixed'
  }
};

var LayoutBase$1 = function LayoutBase(_ref) {
  var Cell = _ref.cellComponent,
      Row = _ref.rowComponent,
      cellsData = _ref.cellsData,
      classes = _ref.classes,
      className = _ref.className,
      formatDate = _ref.formatDate,
      restProps = _objectWithoutProperties(_ref, ["cellComponent", "rowComponent", "cellsData", "classes", "className", "formatDate"]);

  return React.createElement(TableMUI, _extends({}, restProps, {
    className: classNames(classes.table, className)
  }), React.createElement(TableBody, null, cellsData.map(function (days, index) {
    return React.createElement(Row, {
      key: days[0].startDate
    }, index % 2 ? null : React.createElement(Cell, {
      rowSpan: "2",
      startDate: days[0].startDate,
      endDate: days[0].endDate,
      formatDate: formatDate
    }));
  })));
};

process.env.NODE_ENV !== "production" ? LayoutBase$1.propTypes = {
  // oneOfType is a workaround because withStyles returns react object
  classes: PropTypes.object.isRequired,
  cellsData: PropTypes.arrayOf(Array).isRequired,
  cellComponent: PropTypes.oneOfType([PropTypes.func, PropTypes.object]).isRequired,
  rowComponent: PropTypes.oneOfType([PropTypes.func, PropTypes.object]).isRequired,
  formatDate: PropTypes.func.isRequired,
  className: PropTypes.string
} : void 0;
LayoutBase$1.defaultProps = {
  className: undefined
};
var Layout = styles$J.withStyles(styles$4, {
  name: 'Layout'
})(LayoutBase$1);

var styles$5 = function styles(theme) {
  return {
    cell: {
      userSelect: 'none',
      border: 0,
      height: theme.spacing(12) + 2,
      padding: 0,
      overflow: 'hidden',
      textOverflow: 'ellipsis',
      textAlign: 'right',
      '&:last-child': {
        paddingLeft: theme.spacing(0.25),
        paddingRight: theme.spacing(0.5)
      }
    },
    text: _objectSpread2({}, theme.typography.caption, {
      whiteSpace: 'nowrap'
    })
  };
};

var CellBase = React.memo(function (_ref) {
  var classes = _ref.classes,
      className = _ref.className,
      startDate = _ref.startDate,
      endDate = _ref.endDate,
      formatDate = _ref.formatDate,
      restProps = _objectWithoutProperties(_ref, ["classes", "className", "startDate", "endDate", "formatDate"]);

  return React.createElement(TableCell, _extends({
    className: classNames(classes.cell, className)
  }, restProps), React.createElement("span", {
    className: classes.text
  }, formatDate(endDate, dxSchedulerCore.HOUR_MINUTE_OPTIONS)));
});
CellBase.propTypes = {
  formatDate: PropTypes.func.isRequired,
  endDate: PropTypes.instanceOf(Date).isRequired,
  startDate: PropTypes.instanceOf(Date),
  classes: PropTypes.object.isRequired,
  className: PropTypes.string
};
CellBase.defaultProps = {
  className: undefined,
  startDate: undefined
};
var Cell = styles$J.withStyles(styles$5, {
  name: 'Cell'
})(CellBase);

var styles$6 = {
  table: {
    tableLayout: 'fixed'
  }
};

var LayoutBase$2 =
/*#__PURE__*/
function (_React$PureComponent) {
  _inherits(LayoutBase, _React$PureComponent);

  function LayoutBase(props) {
    var _this;

    _classCallCheck(this, LayoutBase);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(LayoutBase).call(this, props));
    _this.table = React.createRef();
    return _this;
  }

  _createClass(LayoutBase, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      this.setCells();
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate() {
      this.setCells();
    }
  }, {
    key: "setCells",
    value: function setCells() {
      var setCellElementsMeta = this.props.setCellElementsMeta;
      var tableElement = this.table.current;
      setCellElementsMeta(cellsMeta(tableElement));
    }
  }, {
    key: "render",
    value: function render() {
      var _this$props = this.props,
          setCellElementsMeta = _this$props.setCellElementsMeta,
          Cell = _this$props.cellComponent,
          Row = _this$props.rowComponent,
          classes = _this$props.classes,
          className = _this$props.className,
          cellsData = _this$props.cellsData,
          formatDate = _this$props.formatDate,
          restProps = _objectWithoutProperties(_this$props, ["setCellElementsMeta", "cellComponent", "rowComponent", "classes", "className", "cellsData", "formatDate"]);

      return React.createElement(TableMUI, _extends({
        ref: this.table,
        className: classNames(classes.table, className)
      }, restProps), React.createElement(TableBody, null, cellsData.map(function (days, index) {
        return React.createElement(Row, {
          key: index.toString()
        }, days.map(function (_ref) {
          var startDate = _ref.startDate,
              endDate = _ref.endDate;
          return React.createElement(Cell, {
            key: startDate,
            startDate: startDate,
            endDate: endDate
          });
        }));
      })));
    }
  }]);

  return LayoutBase;
}(React.PureComponent);

process.env.NODE_ENV !== "production" ? LayoutBase$2.propTypes = {
  // oneOfType is a workaround because withStyles returns react object
  classes: PropTypes.object.isRequired,
  cellsData: PropTypes.arrayOf(Array).isRequired,
  cellComponent: PropTypes.oneOfType([PropTypes.func, PropTypes.object]).isRequired,
  rowComponent: PropTypes.oneOfType([PropTypes.func, PropTypes.object]).isRequired,
  formatDate: PropTypes.func.isRequired,
  setCellElementsMeta: PropTypes.func.isRequired,
  className: PropTypes.string
} : void 0;
LayoutBase$2.defaultProps = {
  className: undefined
};
var Layout$1 = styles$J.withStyles(styles$6, {
  name: 'Layout'
})(LayoutBase$2);

var styles$7 = function styles(theme) {
  return {
    cell: {
      height: theme.spacing(6),
      padding: 0,
      borderLeft: getBorder(theme),
      'tr:last-child &': {
        borderBottom: 'none'
      },
      '&:hover': {
        backgroundColor: theme.palette.action.hover
      },
      '&:focus': {
        backgroundColor: colorManipulator.fade(theme.palette.primary.main, 0.15),
        outline: 0
      },
      '&:last-child': {
        paddingRight: 0
      }
    }
  };
};

var CellBase$1 = function CellBase(_ref) {
  var classes = _ref.classes,
      className = _ref.className,
      children = _ref.children,
      startDate = _ref.startDate,
      endDate = _ref.endDate,
      restProps = _objectWithoutProperties(_ref, ["classes", "className", "children", "startDate", "endDate"]);

  return React.createElement(TableCell, _extends({
    tabIndex: 0,
    className: classNames(classes.cell, className)
  }, restProps), children);
};

process.env.NODE_ENV !== "production" ? CellBase$1.propTypes = {
  classes: PropTypes.object.isRequired,
  startDate: PropTypes.instanceOf(Date),
  endDate: PropTypes.instanceOf(Date),
  children: PropTypes.node,
  className: PropTypes.string
} : void 0;
CellBase$1.defaultProps = {
  children: null,
  className: undefined,
  startDate: undefined,
  endDate: undefined
};
var Cell$1 = styles$J.withStyles(styles$7, {
  name: 'Cell'
})(CellBase$1);

var styles$8 = {
  table: {
    tableLayout: 'fixed'
  }
};

var LayoutBase$3 = function LayoutBase(_ref) {
  var Cell = _ref.cellComponent,
      Row = _ref.rowComponent,
      cellsData = _ref.cellsData,
      className = _ref.className,
      classes = _ref.classes,
      formatDate = _ref.formatDate,
      restProps = _objectWithoutProperties(_ref, ["cellComponent", "rowComponent", "cellsData", "className", "classes", "formatDate"]);

  return React.createElement(TableMUI, _extends({
    className: classNames(classes.table, className)
  }, restProps), React.createElement(TableBody, null, React.createElement(Row, null, cellsData[0].map(function (_ref2, index) {
    var startDate = _ref2.startDate,
        endDate = _ref2.endDate,
        today = _ref2.today;
    return React.createElement(Cell, {
      key: index.toString(),
      startDate: startDate,
      endDate: endDate,
      today: today,
      formatDate: formatDate
    });
  }))));
};

process.env.NODE_ENV !== "production" ? LayoutBase$3.propTypes = {
  // oneOfType is a workaround because withStyles returns react object
  classes: PropTypes.object.isRequired,
  cellsData: PropTypes.arrayOf(Array).isRequired,
  cellComponent: PropTypes.oneOfType([PropTypes.func, PropTypes.object]).isRequired,
  rowComponent: PropTypes.oneOfType([PropTypes.func, PropTypes.object]).isRequired,
  formatDate: PropTypes.func.isRequired,
  className: PropTypes.string
} : void 0;
LayoutBase$3.defaultProps = {
  className: undefined
};
var Layout$2 = styles$J.withStyles(styles$8, {
  name: 'Layout'
})(LayoutBase$3);

var styles$9 = function styles(theme) {
  return {
    cell: {
      userSelect: 'none',
      paddingBottom: 0,
      borderLeft: getBorder(theme),
      '&:last-child': {
        paddingRight: 0
      }
    },
    dayOfWeek: _objectSpread2({}, theme.typography.caption, {
      margin: 0
    }),
    dayOfMonth: _objectSpread2({}, theme.typography.h4),
    highlightCell: {
      color: theme.palette.primary.main
    }
  };
};

var CellBase$2 = React.memo(function (_ref) {
  var _classNames, _classNames2;

  var classes = _ref.classes,
      className = _ref.className,
      startDate = _ref.startDate,
      endDate = _ref.endDate,
      today = _ref.today,
      formatDate = _ref.formatDate,
      restProps = _objectWithoutProperties(_ref, ["classes", "className", "startDate", "endDate", "today", "formatDate"]);

  return React.createElement(TableCell, _extends({
    className: classNames(classes.cell, className)
  }, restProps), React.createElement("p", {
    className: classNames((_classNames = {}, _defineProperty(_classNames, classes.dayOfWeek, true), _defineProperty(_classNames, classes.highlightCell, today), _classNames))
  }, formatDate(startDate, dxSchedulerCore.WEEK_DAY_OPTIONS)), React.createElement("span", {
    className: classNames((_classNames2 = {}, _defineProperty(_classNames2, classes.dayOfMonth, true), _defineProperty(_classNames2, classes.highlightCell, today), _classNames2))
  }, formatDate(startDate, dxSchedulerCore.DAY_OPTIONS)));
});
CellBase$2.propTypes = {
  classes: PropTypes.object.isRequired,
  formatDate: PropTypes.func.isRequired,
  startDate: PropTypes.instanceOf(Date).isRequired,
  endDate: PropTypes.instanceOf(Date),
  className: PropTypes.string,
  today: PropTypes.bool
};
CellBase$2.defaultProps = {
  className: undefined,
  endDate: undefined,
  today: false
};
var Cell$2 = styles$J.withStyles(styles$9, {
  name: 'Cell'
})(CellBase$2);

var DayView = dxReactCore.withComponents({
  Layout: VerticalViewLayout,
  AppointmentLayer: Container,
  DayScaleEmptyCell: DayScaleEmptyCell,
  TimeScaleLayout: Layout,
  TimeScaleCell: Cell,
  TimeScaleRow: Row,
  DayScaleLayout: Layout$2,
  DayScaleCell: Cell$2,
  DayScaleRow: Row,
  TimeTableLayout: Layout$1,
  TimeTableCell: Cell$1,
  TimeTableRow: Row
})(dxReactScheduler.DayView);

var WeekView = dxReactCore.withComponents({
  Layout: VerticalViewLayout,
  AppointmentLayer: Container,
  DayScaleEmptyCell: DayScaleEmptyCell,
  TimeScaleLayout: Layout,
  TimeScaleCell: Cell,
  TimeScaleRow: Row,
  DayScaleLayout: Layout$2,
  DayScaleCell: Cell$2,
  DayScaleRow: Row,
  TimeTableLayout: Layout$1,
  TimeTableCell: Cell$1,
  TimeTableRow: Row
})(dxReactScheduler.WeekView);

var styles$a = function styles(theme) {
  return {
    container: {
      overflowY: 'auto',
      position: 'relative'
    },
    stickyHeader: {
      top: 0,
      zIndex: 1,
      tableLayout: 'fixed',
      position: 'sticky',
      overflow: 'visible',
      background: theme.palette.background.paper
    },
    timeTable: {
      position: 'relative'
    }
  };
};

var HorizontalViewLayoutBase =
/*#__PURE__*/
function (_React$PureComponent) {
  _inherits(HorizontalViewLayoutBase, _React$PureComponent);

  function HorizontalViewLayoutBase(props) {
    var _this;

    _classCallCheck(this, HorizontalViewLayoutBase);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(HorizontalViewLayoutBase).call(this, props));
    _this.layout = React.createRef();
    _this.layoutHeader = React.createRef();
    return _this;
  }

  _createClass(HorizontalViewLayoutBase, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      this.setScrollingStrategy();
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate() {
      this.setScrollingStrategy();
    }
  }, {
    key: "setScrollingStrategy",
    value: function setScrollingStrategy() {
      var setScrollingStrategy = this.props.setScrollingStrategy;
      setScrollingStrategy(scrollingStrategy(this.layout.current, this.layoutHeader.current));
    }
  }, {
    key: "render",
    value: function render() {
      var _this$props = this.props,
          DayScale = _this$props.dayScaleComponent,
          TimeTable = _this$props.timeTableComponent,
          setScrollingStrategy = _this$props.setScrollingStrategy,
          classes = _this$props.classes,
          className = _this$props.className,
          restProps = _objectWithoutProperties(_this$props, ["dayScaleComponent", "timeTableComponent", "setScrollingStrategy", "classes", "className"]);

      return React.createElement(Grid, _extends({
        ref: this.layout,
        className: classNames(classes.container, className),
        container: true,
        direction: "column",
        wrap: "nowrap"
      }, restProps), React.createElement("div", null, React.createElement(Grid, {
        ref: this.layoutHeader,
        item: true,
        className: classes.stickyHeader
      }, React.createElement(DayScale, null)), React.createElement(Grid, {
        item: true,
        className: classes.timeTable
      }, React.createElement(TimeTable, null))));
    }
  }]);

  return HorizontalViewLayoutBase;
}(React.PureComponent);

process.env.NODE_ENV !== "production" ? HorizontalViewLayoutBase.propTypes = {
  // oneOfType is a workaround because withStyles returns react object
  dayScaleComponent: PropTypes.oneOfType([PropTypes.func, PropTypes.object]).isRequired,
  timeTableComponent: PropTypes.oneOfType([PropTypes.func, PropTypes.object]).isRequired,
  setScrollingStrategy: PropTypes.func.isRequired,
  classes: PropTypes.object.isRequired,
  className: PropTypes.string
} : void 0;
HorizontalViewLayoutBase.defaultProps = {
  className: undefined
};
var HorizontalViewLayout = styles$J.withStyles(styles$a, {
  name: 'HorizontalViewLayout'
})(HorizontalViewLayoutBase);

var styles$b = {
  table: {
    tableLayout: 'fixed'
  }
};

var LayoutBase$4 =
/*#__PURE__*/
function (_React$PureComponent) {
  _inherits(LayoutBase, _React$PureComponent);

  function LayoutBase(props) {
    var _this;

    _classCallCheck(this, LayoutBase);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(LayoutBase).call(this, props));
    _this.table = React.createRef();
    return _this;
  }

  _createClass(LayoutBase, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      this.setCells();
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate() {
      this.setCells();
    }
  }, {
    key: "setCells",
    value: function setCells() {
      var setCellElementsMeta = this.props.setCellElementsMeta;
      var tableElement = this.table.current;
      setCellElementsMeta(cellsMeta(tableElement));
    }
  }, {
    key: "render",
    value: function render() {
      var _this$props = this.props,
          setCellElementsMeta = _this$props.setCellElementsMeta,
          Cell = _this$props.cellComponent,
          Row = _this$props.rowComponent,
          classes = _this$props.classes,
          className = _this$props.className,
          cellsData = _this$props.cellsData,
          formatDate = _this$props.formatDate,
          restProps = _objectWithoutProperties(_this$props, ["setCellElementsMeta", "cellComponent", "rowComponent", "classes", "className", "cellsData", "formatDate"]);

      return React.createElement(TableMUI, _extends({
        ref: this.table,
        className: classNames(classes.table, className)
      }, restProps), React.createElement(TableBody, null, cellsData.map(function (row) {
        return React.createElement(Row, {
          key: row[0].startDate.toString()
        }, row.map(function (_ref) {
          var startDate = _ref.startDate,
              endDate = _ref.endDate,
              today = _ref.today,
              otherMonth = _ref.otherMonth;
          return React.createElement(Cell, {
            key: startDate,
            startDate: startDate,
            endDate: endDate,
            today: today,
            otherMonth: otherMonth,
            formatDate: formatDate
          });
        }));
      })));
    }
  }]);

  return LayoutBase;
}(React.PureComponent);

process.env.NODE_ENV !== "production" ? LayoutBase$4.propTypes = {
  // oneOfType is a workaround because withStyles returns react object
  cellsData: PropTypes.arrayOf(Array).isRequired,
  classes: PropTypes.object.isRequired,
  cellComponent: PropTypes.oneOfType([PropTypes.func, PropTypes.object]).isRequired,
  rowComponent: PropTypes.oneOfType([PropTypes.func, PropTypes.object]).isRequired,
  formatDate: PropTypes.func.isRequired,
  setCellElementsMeta: PropTypes.func.isRequired,
  className: PropTypes.string
} : void 0;
LayoutBase$4.defaultProps = {
  className: undefined
};
var Layout$3 = styles$J.withStyles(styles$b, {
  name: 'Layout'
})(LayoutBase$4);

var styles$c = function styles(theme) {
  return {
    cell: {
      userSelect: 'none',
      verticalAlign: 'top',
      padding: 0,
      height: 100,
      borderLeft: getBorder(theme),
      '&:first-child': {
        borderLeft: 'none'
      },
      '&:last-child': {
        paddingRight: 0
      },
      'tr:last-child &': {
        borderBottom: 'none'
      },
      '&:hover': {
        backgroundColor: theme.palette.action.hover
      },
      '&:focus': {
        backgroundColor: colorManipulator.fade(theme.palette.primary.main, 0.15),
        outline: 0
      }
    },
    text: {
      padding: '1em'
    },
    today: {
      margin: '0.85em',
      display: 'inline-block',
      width: '1.72em',
      height: '1.72em',
      lineHeight: 1.72,
      textAlign: 'center',
      borderRadius: '50%',
      background: theme.palette.primary.main,
      color: theme.palette.primary.contrastText,
      cursor: 'default'
    },
    otherMonth: {
      color: theme.palette.text.disabled
    }
  };
};

var CellBase$3 = React.memo(function (_ref) {
  var _classNames;

  var classes = _ref.classes,
      className = _ref.className,
      startDate = _ref.startDate,
      endDate = _ref.endDate,
      today = _ref.today,
      otherMonth = _ref.otherMonth,
      formatDate = _ref.formatDate,
      restProps = _objectWithoutProperties(_ref, ["classes", "className", "startDate", "endDate", "today", "otherMonth", "formatDate"]);

  var isFirstMonthDay = startDate.getDate() === 1;
  var formatOptions = isFirstMonthDay ? dxSchedulerCore.DAY_SHORT_MONTH_OPTIONS : dxSchedulerCore.DAY_OPTIONS;
  return React.createElement(TableCell, _extends({
    tabIndex: 0,
    className: classNames(classes.cell, className)
  }, restProps), React.createElement("div", {
    className: classNames((_classNames = {}, _defineProperty(_classNames, classes.text, !today), _defineProperty(_classNames, classes.today, today), _defineProperty(_classNames, classes.otherMonth, otherMonth && !today), _classNames))
  }, formatDate(startDate, formatOptions)));
});
process.env.NODE_ENV !== "production" ? CellBase$3.propTypes = {
  classes: PropTypes.object.isRequired,
  formatDate: PropTypes.func.isRequired,
  startDate: PropTypes.instanceOf(Date).isRequired,
  endDate: PropTypes.instanceOf(Date),
  className: PropTypes.string,
  today: PropTypes.bool,
  otherMonth: PropTypes.bool
} : void 0;
CellBase$3.defaultProps = {
  endDate: undefined,
  className: undefined,
  today: false,
  otherMonth: false
};
var Cell$3 = styles$J.withStyles(styles$c, {
  name: 'Cell'
})(CellBase$3);

var styles$d = function styles(theme) {
  return {
    cell: {
      userSelect: 'none',
      padding: 0,
      borderLeft: getBorder(theme),
      '&:first-child': {
        borderLeft: 'none'
      },
      '&:last-child': {
        paddingRight: 0
      }
    },
    dayOfWeek: _objectSpread2({}, theme.typography.caption, {
      margin: 0,
      padding: theme.spacing(1)
    })
  };
};

var CellBase$4 = React.memo(function (_ref) {
  var classes = _ref.classes,
      className = _ref.className,
      startDate = _ref.startDate,
      endDate = _ref.endDate,
      today = _ref.today,
      formatDate = _ref.formatDate,
      restProps = _objectWithoutProperties(_ref, ["classes", "className", "startDate", "endDate", "today", "formatDate"]);

  return React.createElement(TableCell, _extends({
    className: classNames(classes.cell, className)
  }, restProps), React.createElement("div", {
    className: classes.dayOfWeek
  }, formatDate(startDate, dxSchedulerCore.WEEK_DAY_OPTIONS)));
});
CellBase$4.propTypes = {
  classes: PropTypes.object.isRequired,
  formatDate: PropTypes.func.isRequired,
  startDate: PropTypes.instanceOf(Date).isRequired,
  endDate: PropTypes.instanceOf(Date),
  className: PropTypes.string,
  today: PropTypes.bool
};
CellBase$4.defaultProps = {
  className: undefined,
  endDate: undefined,
  today: false
};
var Cell$4 = styles$J.withStyles(styles$d, {
  name: 'Cell'
})(CellBase$4);

var MonthView = dxReactCore.withComponents({
  Layout: HorizontalViewLayout,
  AppointmentLayer: Container,
  DayScaleLayout: Layout$2,
  DayScaleCell: Cell$4,
  DayScaleRow: Row,
  TimeTableLayout: Layout$3,
  TimeTableCell: Cell$3,
  TimeTableRow: Row
})(dxReactScheduler.MonthView);

var styles$e = function styles(_ref) {
  var palette = _ref.palette,
      spacing = _ref.spacing;
  return {
    title: {
      overflow: 'hidden',
      textOverflow: 'ellipsis',
      whiteSpace: 'nowrap'
    },
    content: {
      color: palette.common.white,
      padding: spacing(0.5),
      overflow: 'hidden',
      textOverflow: 'ellipsis',
      whiteSpace: 'nowrap',
      display: 'flex'
    },
    container: {
      width: '100%'
    },
    recurringContainer: {
      width: "calc(100% - ".concat(spacing(2), "px)")
    },
    imageContainer: {
      width: spacing(2),
      height: spacing(2)
    },
    image: {
      width: '100%',
      height: '100%'
    }
  };
};

var HorizontalAppointmentBase = function HorizontalAppointmentBase(_ref2) {
  var classes = _ref2.classes,
      data = _ref2.data,
      children = _ref2.children,
      className = _ref2.className,
      RecurringIcon = _ref2.recurringIconComponent,
      formatDate = _ref2.formatDate,
      restProps = _objectWithoutProperties(_ref2, ["classes", "data", "children", "className", "recurringIconComponent", "formatDate"]);

  var repeat = !!data.rRule;
  return React.createElement("div", _extends({
    className: classNames(classes.content, className)
  }, restProps), children || React.createElement(React.Fragment, null, React.createElement("div", {
    className: repeat ? classes.recurringContainer : classes.container
  }, React.createElement("div", {
    className: classes.title
  }, data.title)), repeat ? React.createElement("div", {
    className: classes.imageContainer
  }, React.createElement(RecurringIcon, {
    className: classes.image
  })) : undefined));
};

process.env.NODE_ENV !== "production" ? HorizontalAppointmentBase.propTypes = {
  // oneOfType is a workaround because withStyles returns react object
  recurringIconComponent: PropTypes.oneOfType([PropTypes.func, PropTypes.object]).isRequired,
  classes: PropTypes.object.isRequired,
  data: PropTypes.object.isRequired,
  children: PropTypes.node,
  className: PropTypes.string,
  formatDate: PropTypes.func
} : void 0;
HorizontalAppointmentBase.defaultProps = {
  formatDate: function formatDate() {
    return '';
  },
  children: undefined,
  className: undefined
};
var HorizontalAppointment = styles$J.withStyles(styles$e, {
  name: 'HorizontalAppointment'
})(HorizontalAppointmentBase);

var styles$f = function styles(_ref) {
  var palette = _ref.palette,
      spacing = _ref.spacing;
  return {
    title: {
      fontWeight: 'bold',
      overflow: 'hidden',
      textOverflow: 'ellipsis',
      whiteSpace: 'nowrap'
    },
    textContainer: {
      lineHeight: 1,
      whiteSpace: 'pre-wrap',
      overflow: 'hidden',
      textOverflow: 'ellipsis'
    },
    time: {
      display: 'inline-block',
      overflow: 'hidden',
      textOverflow: 'ellipsis'
    },
    content: {
      color: palette.common.white,
      padding: spacing(0.5, 1),
      overflow: 'hidden',
      textOverflow: 'ellipsis',
      whiteSpace: 'nowrap',
      display: 'flex'
    },
    container: {
      width: '100%'
    },
    recurringContainer: {
      width: "calc(100% - ".concat(spacing(2), "px)")
    },
    imageContainer: {
      width: spacing(2),
      height: spacing(2)
    },
    image: {
      width: '100%',
      height: '100%'
    }
  };
};

var VerticalAppointmentBase = function VerticalAppointmentBase(_ref2) {
  var classes = _ref2.classes,
      data = _ref2.data,
      children = _ref2.children,
      className = _ref2.className,
      formatDate = _ref2.formatDate,
      RecurringIcon = _ref2.recurringIconComponent,
      restProps = _objectWithoutProperties(_ref2, ["classes", "data", "children", "className", "formatDate", "recurringIconComponent"]);

  var repeat = !!data.rRule;
  return React.createElement("div", _extends({
    className: classNames(classes.content, className)
  }, restProps), children || React.createElement(React.Fragment, null, React.createElement("div", {
    className: repeat ? classes.recurringContainer : classes.container
  }, React.createElement("div", {
    className: classes.title
  }, data.title), React.createElement("div", {
    className: classes.textContainer
  }, React.createElement("div", {
    className: classes.time
  }, formatDate(data.startDate, dxSchedulerCore.HOUR_MINUTE_OPTIONS)), React.createElement("div", {
    className: classes.time
  }, ' - '), React.createElement("div", {
    className: classes.time
  }, formatDate(data.endDate, dxSchedulerCore.HOUR_MINUTE_OPTIONS)))), repeat ? React.createElement("div", {
    className: classes.imageContainer
  }, React.createElement(RecurringIcon, {
    className: classes.image
  })) : undefined));
};

process.env.NODE_ENV !== "production" ? VerticalAppointmentBase.propTypes = {
  // oneOfType is a workaround because withStyles returns react object
  recurringIconComponent: PropTypes.oneOfType([PropTypes.func, PropTypes.object]).isRequired,
  classes: PropTypes.object.isRequired,
  data: PropTypes.object.isRequired,
  formatDate: PropTypes.func.isRequired,
  children: PropTypes.node,
  className: PropTypes.string
} : void 0;
VerticalAppointmentBase.defaultProps = {
  children: undefined,
  className: undefined
};
var VerticalAppointment = styles$J.withStyles(styles$f, {
  name: 'VerticalAppointment'
})(VerticalAppointmentBase);

var AppointmentContent = function AppointmentContent(_ref) {
  var type = _ref.type,
      restProps = _objectWithoutProperties(_ref, ["type"]);

  return type === dxSchedulerCore.HORIZONTAL_TYPE ? React.createElement(HorizontalAppointment, restProps) : React.createElement(VerticalAppointment, restProps);
};
process.env.NODE_ENV !== "production" ? AppointmentContent.propTypes = {
  type: PropTypes.oneOf([dxSchedulerCore.HORIZONTAL_TYPE, dxSchedulerCore.VERTICAL_TYPE]).isRequired
} : void 0;

var styles$g = function styles(_ref) {
  var palette = _ref.palette,
      typography = _ref.typography,
      spacing = _ref.spacing;
  return {
    appointment: _objectSpread2({
      userSelect: 'none',
      position: 'absolute',
      height: '100%',
      width: '100%',
      overflow: 'hidden',
      boxSizing: 'border-box',
      // fix no space between appointments bug in Firefox (https://bugzilla.mozilla.org/show_bug.cgi?id=989340)
      borderRight: '2px solid transparent',
      borderBottom: '1px solid transparent',
      backgroundClip: 'padding-box',
      borderRadius: spacing(0.5),
      backgroundColor: setColor(300, palette.primary)
    }, typography.caption, {
      '&:hover': {
        backgroundColor: setColor(400, palette.primary)
      },
      '&:focus': {
        backgroundColor: setColor(100, palette.primary),
        outline: 0
      }
    }),
    clickableAppointment: {
      cursor: 'pointer'
    }
  };
};

var AppointmentBase = function AppointmentBase(_ref2) {
  var _classNames;

  var classes = _ref2.classes,
      className = _ref2.className,
      children = _ref2.children,
      data = _ref2.data,
      handleClick = _ref2.onClick,
      draggable = _ref2.draggable,
      restProps = _objectWithoutProperties(_ref2, ["classes", "className", "children", "data", "onClick", "draggable"]);

  var onClick = handleClick ? {
    onClick: function onClick(_ref3) {
      var target = _ref3.target;
      handleClick({
        target: target,
        data: data
      });
    }
  } : null;
  var clickable = onClick || restProps.onDoubleClick || draggable;
  return React.createElement("div", _extends({
    className: classNames((_classNames = {}, _defineProperty(_classNames, classes.appointment, true), _defineProperty(_classNames, classes.clickableAppointment, clickable), _classNames), className)
  }, onClick, restProps), children);
};

process.env.NODE_ENV !== "production" ? AppointmentBase.propTypes = {
  classes: PropTypes.object.isRequired,
  children: PropTypes.node.isRequired,
  className: PropTypes.string,
  data: PropTypes.object,
  onClick: PropTypes.func,
  draggable: PropTypes.bool
} : void 0;
AppointmentBase.defaultProps = {
  onClick: undefined,
  className: undefined,
  data: {},
  draggable: false
};
var Appointment = styles$J.withStyles(styles$g, {
  name: 'Appointment'
})(AppointmentBase);

var verticalStyles = {
  width: '100%',
  height: '10px'
};
var horizontalStyles = {
  top: 0,
  width: '10px',
  height: '100%'
};
var styles$h = {
  slice: {
    position: 'absolute',
    zIndex: 50
  },
  verticalStart: _objectSpread2({}, verticalStyles, {
    top: '-10px',
    boxShadow: '0 10px 15px rgba(0,0,0,0.2)'
  }),
  verticalEnd: _objectSpread2({}, verticalStyles, {
    bottom: '-10px',
    boxShadow: '0 -10px 15px rgba(0,0,0,0.2)'
  }),
  horizontalStart: _objectSpread2({}, horizontalStyles, {
    left: '-10px',
    boxShadow: '10px 0 15px rgba(0,0,0,0.2)'
  }),
  horizontalEnd: _objectSpread2({}, horizontalStyles, {
    right: '-10px',
    boxShadow: '-10px 0 15px rgba(0,0,0,0.2)'
  })
};
var SplitIndicatorBase = React.memo(function (_ref) {
  var _classNames;

  var position = _ref.position,
      appointmentType = _ref.appointmentType,
      classes = _ref.classes,
      className = _ref.className,
      restProps = _objectWithoutProperties(_ref, ["position", "appointmentType", "classes", "className"]);

  var vertical = appointmentType === dxSchedulerCore.VERTICAL_TYPE;
  var start = position === dxSchedulerCore.POSITION_START;
  return React.createElement("div", _extends({
    className: classNames((_classNames = {}, _defineProperty(_classNames, classes.slice, true), _defineProperty(_classNames, classes.verticalStart, vertical && start), _defineProperty(_classNames, classes.verticalEnd, vertical && !start), _defineProperty(_classNames, classes.horizontalStart, !vertical && start), _defineProperty(_classNames, classes.horizontalEnd, !vertical && !start), _classNames), className)
  }, restProps));
});
process.env.NODE_ENV !== "production" ? SplitIndicatorBase.propTypes = {
  classes: PropTypes.object.isRequired,
  appointmentType: PropTypes.oneOf([dxSchedulerCore.VERTICAL_TYPE, dxSchedulerCore.HORIZONTAL_TYPE]).isRequired,
  position: PropTypes.oneOf([dxSchedulerCore.POSITION_START, dxSchedulerCore.POSITION_END]).isRequired,
  className: PropTypes.string
} : void 0;
SplitIndicatorBase.defaultProps = {
  className: undefined
};
var SplitIndicator = styles$J.withStyles(styles$h, {
  name: 'AppointmentsContainer'
})(SplitIndicatorBase);

var AppointmentContainer = function AppointmentContainer(_ref) {
  var style = _ref.style,
      children = _ref.children,
      restProps = _objectWithoutProperties(_ref, ["style", "children"]);

  return React.createElement("div", _extends({
    style: style
  }, restProps), children);
};
process.env.NODE_ENV !== "production" ? AppointmentContainer.propTypes = {
  children: PropTypes.node.isRequired,
  style: PropTypes.object.isRequired
} : void 0;

var Appointments = dxReactCore.withComponents({
  Appointment: Appointment,
  AppointmentContent: AppointmentContent,
  Container: AppointmentContainer,
  SplitIndicator: SplitIndicator,
  RecurringIcon: Repeat
})(dxReactScheduler.Appointments);

var styles$i = function styles(theme) {
  return {
    toolbar: {
      borderBottom: getBorder(theme)
    }
  };
};

var ToolbarBase = function ToolbarBase(_ref) {
  var children = _ref.children,
      classes = _ref.classes,
      className = _ref.className,
      restProps = _objectWithoutProperties(_ref, ["children", "classes", "className"]);

  return React.createElement(ToolbarMUI, _extends({
    className: classNames(classes.toolbar, className)
  }, restProps), children);
};

process.env.NODE_ENV !== "production" ? ToolbarBase.propTypes = {
  children: PropTypes.node.isRequired,
  classes: PropTypes.object.isRequired,
  className: PropTypes.string
} : void 0;
ToolbarBase.defaultProps = {
  className: undefined
};
var Toolbar = styles$J.withStyles(styles$i, {
  name: 'Toolbar'
})(ToolbarBase);

var styles$j = {
  flexibleSpace: {
    flex: '0 0 0',
    marginLeft: 'auto'
  }
};
var FlexibleSpaceBase = function FlexibleSpaceBase(_ref) {
  var children = _ref.children,
      classes = _ref.classes,
      className = _ref.className,
      restProps = _objectWithoutProperties(_ref, ["children", "classes", "className"]);

  return React.createElement("div", _extends({
    className: classNames(classes.flexibleSpace, className)
  }, restProps), children);
};
process.env.NODE_ENV !== "production" ? FlexibleSpaceBase.propTypes = {
  classes: PropTypes.object.isRequired,
  children: PropTypes.node,
  className: PropTypes.string
} : void 0;
FlexibleSpaceBase.defaultProps = {
  children: null,
  className: undefined
};
var FlexibleSpace = styles$J.withStyles(styles$j, {
  name: 'FlexibleSpace'
})(FlexibleSpaceBase);

var Toolbar$1 = dxReactCore.withComponents({
  Root: Toolbar,
  FlexibleSpace: FlexibleSpace
})(dxReactScheduler.Toolbar);

var styles$k = function styles(_ref) {
  var spacing = _ref.spacing;
  return {
    root: {
      marginLeft: spacing(0.5),
      '&:first-child': {
        marginLeft: 0
      }
    }
  };
};

var RootBase = function RootBase(_ref2) {
  var NavigationButton = _ref2.navigationButtonComponent,
      OpenButton = _ref2.openButtonComponent,
      navigatorText = _ref2.navigatorText,
      rootRef = _ref2.rootRef,
      onVisibilityToggle = _ref2.onVisibilityToggle,
      onNavigate = _ref2.onNavigate,
      className = _ref2.className,
      classes = _ref2.classes,
      restProps = _objectWithoutProperties(_ref2, ["navigationButtonComponent", "openButtonComponent", "navigatorText", "rootRef", "onVisibilityToggle", "onNavigate", "className", "classes"]);

  var navigateBack = React.useCallback(function () {
    return onNavigate('back');
  }, [onNavigate]);
  var navigateForward = React.useCallback(function () {
    return onNavigate('forward');
  }, [onNavigate]);
  return React.createElement("div", _extends({
    className: classNames(classes.root, className),
    ref: rootRef
  }, restProps), React.createElement(NavigationButton, {
    type: "back",
    onClick: navigateBack
  }), React.createElement(NavigationButton, {
    type: "forward",
    onClick: navigateForward
  }), React.createElement(OpenButton, {
    onVisibilityToggle: onVisibilityToggle,
    text: navigatorText
  }));
};

process.env.NODE_ENV !== "production" ? RootBase.propTypes = {
  // oneOfType is a workaround because withStyles returns react object
  navigationButtonComponent: PropTypes.oneOfType([PropTypes.func, PropTypes.object]).isRequired,
  openButtonComponent: PropTypes.oneOfType([PropTypes.func, PropTypes.object]).isRequired,
  onVisibilityToggle: PropTypes.func.isRequired,
  onNavigate: PropTypes.func.isRequired,
  rootRef: PropTypes.func.isRequired,
  navigatorText: PropTypes.string,
  classes: PropTypes.object.isRequired,
  className: PropTypes.string
} : void 0;
RootBase.defaultProps = {
  navigatorText: '',
  className: undefined
};
var Root$1 = styles$J.withStyles(styles$k)(RootBase, {
  name: 'Root'
});

var origin = {
  vertical: 'top',
  horizontal: 'right'
};
var Overlay = function Overlay(_ref) {
  var visible = _ref.visible,
      onHide = _ref.onHide,
      children = _ref.children,
      target = _ref.target,
      restProps = _objectWithoutProperties(_ref, ["visible", "onHide", "children", "target"]);

  return React.createElement(Popover, _extends({
    open: visible,
    anchorEl: target,
    onClose: onHide,
    anchorOrigin: origin,
    transformOrigin: origin
  }, restProps), children);
};
process.env.NODE_ENV !== "production" ? Overlay.propTypes = {
  onHide: PropTypes.func.isRequired,
  children: PropTypes.node.isRequired,
  visible: PropTypes.bool,
  target: PropTypes.oneOfType([PropTypes.object, PropTypes.func])
} : void 0;
Overlay.defaultProps = {
  visible: false,
  target: null
};

var OpenButton = React.memo(function (_ref) {
  var text = _ref.text,
      onVisibilityToggle = _ref.onVisibilityToggle,
      restProps = _objectWithoutProperties(_ref, ["text", "onVisibilityToggle"]);

  return React.createElement(Button$1, _extends({
    onClick: onVisibilityToggle
  }, restProps), text);
});
OpenButton.propTypes = {
  onVisibilityToggle: PropTypes.func.isRequired,
  text: PropTypes.string,
  className: PropTypes.string
};
OpenButton.defaultProps = {
  text: '',
  className: undefined
};

var NavigationButton = React.memo(function (_ref) {
  var type = _ref.type,
      onClick = _ref.onClick,
      restProps = _objectWithoutProperties(_ref, ["type", "onClick"]);

  return React.createElement(IconButton, _extends({
    onClick: onClick
  }, restProps), type === 'back' ? React.createElement(ChevronLeft, null) : React.createElement(ChevronRight, null));
});
NavigationButton.propTypes = {
  type: PropTypes.oneOf(['forward', 'back']).isRequired,
  onClick: PropTypes.func
};
NavigationButton.defaultProps = {
  onClick: function onClick() {}
};

var styles$l = {
  table: {
    width: '320px',
    tableLayout: 'fixed'
  }
};

var TableBase = function TableBase(_ref) {
  var Row = _ref.rowComponent,
      Cell = _ref.cellComponent,
      HeaderRow = _ref.headerRowComponent,
      HeaderCell = _ref.headerCellComponent,
      classes = _ref.classes,
      className = _ref.className,
      cells = _ref.cells,
      headerCells = _ref.headerCells,
      selectedDate = _ref.selectedDate,
      onCellClick = _ref.onCellClick,
      formatDate = _ref.formatDate,
      restProps = _objectWithoutProperties(_ref, ["rowComponent", "cellComponent", "headerRowComponent", "headerCellComponent", "classes", "className", "cells", "headerCells", "selectedDate", "onCellClick", "formatDate"]);

  var comparableSelectedDate = moment(selectedDate);
  return React.createElement(TableMUI, _extends({
    className: classNames(classes.table, className)
  }, restProps), React.createElement(TableHead, null, React.createElement(HeaderRow, null, headerCells.map(function (cell) {
    var key = formatDate(cell.startDate, dxSchedulerCore.WEEK_DAY_OPTIONS);
    return React.createElement(HeaderCell, {
      key: key
    }, key);
  }))), React.createElement(TableBody, null, cells.map(function (row) {
    return React.createElement(Row, {
      key: row[0].startDate.toString()
    }, row.map(function (_ref2) {
      var startDate = _ref2.startDate,
          otherMonth = _ref2.otherMonth,
          today = _ref2.today;
      var selected = comparableSelectedDate.isSame(moment(startDate), 'date');
      return React.createElement(Cell, {
        key: startDate.toString(),
        otherMonth: otherMonth,
        selected: selected,
        today: today,
        onClick: function onClick() {
          onCellClick(startDate);
        }
      }, formatDate(startDate, dxSchedulerCore.DAY_OPTIONS));
    }));
  })));
};

process.env.NODE_ENV !== "production" ? TableBase.propTypes = {
  // oneOfType is a workaround because withStyles returns react object
  rowComponent: PropTypes.oneOfType([PropTypes.func, PropTypes.object]).isRequired,
  cellComponent: PropTypes.oneOfType([PropTypes.func, PropTypes.object]).isRequired,
  headerRowComponent: PropTypes.oneOfType([PropTypes.func, PropTypes.object]).isRequired,
  headerCellComponent: PropTypes.oneOfType([PropTypes.func, PropTypes.object]).isRequired,
  cells: PropTypes.array.isRequired,
  classes: PropTypes.object.isRequired,
  selectedDate: PropTypes.oneOfType([PropTypes.instanceOf(Date), PropTypes.string, PropTypes.number]),
  formatDate: PropTypes.func.isRequired,
  headerCells: PropTypes.array,
  className: PropTypes.string,
  onCellClick: PropTypes.func
} : void 0;
TableBase.defaultProps = {
  className: undefined,
  headerCells: [],
  onCellClick: function onCellClick() {},
  selectedDate: undefined
};
var Table = styles$J.withStyles(styles$l, {
  name: 'Table'
})(TableBase);

var Root$2 =
/*#__PURE__*/
function (_React$PureComponent) {
  _inherits(Root, _React$PureComponent);

  function Root(props) {
    var _this;

    _classCallCheck(this, Root);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(Root).call(this, props));
    var selectedDate = _this.props.selectedDate;
    _this.state = {
      selectedDate: selectedDate,
      currentDate: selectedDate
    };
    _this.onNavigate = _this.onNavigate.bind(_assertThisInitialized(_this));
    _this.onCellClick = _this.onCellClick.bind(_assertThisInitialized(_this));
    return _this;
  }

  _createClass(Root, [{
    key: "onNavigate",
    value: function onNavigate(_ref) {
      var back = _ref.back;
      var currentDateState = this.state.currentDate;
      var nextDate = moment(currentDateState)[back ? 'subtract' : 'add'](1, 'month');
      this.setState({
        currentDate: nextDate.toDate()
      });
    }
  }, {
    key: "onCellClick",
    value: function onCellClick(nextDate) {
      var onSelectedDateChange = this.props.onSelectedDateChange;
      this.setState({
        selectedDate: nextDate,
        currentDate: nextDate
      });
      onSelectedDateChange(nextDate);
    }
  }, {
    key: "render",
    value: function render() {
      var _this$props = this.props,
          selectedDate = _this$props.selectedDate,
          firstDayOfWeek = _this$props.firstDayOfWeek,
          getCells = _this$props.getCells,
          Text = _this$props.textComponent,
          NavigationButton = _this$props.navigationButtonComponent,
          Navigator = _this$props.navigatorComponent,
          Row = _this$props.rowComponent,
          Cell = _this$props.cellComponent,
          HeaderRow = _this$props.headerRowComponent,
          HeaderCell = _this$props.headerCellComponent,
          onSelectedDateChange = _this$props.onSelectedDateChange,
          formatDate = _this$props.formatDate,
          restProps = _objectWithoutProperties(_this$props, ["selectedDate", "firstDayOfWeek", "getCells", "textComponent", "navigationButtonComponent", "navigatorComponent", "rowComponent", "cellComponent", "headerRowComponent", "headerCellComponent", "onSelectedDateChange", "formatDate"]);

      var _this$state = this.state,
          selectedDateState = _this$state.selectedDate,
          currentDate = _this$state.currentDate;
      var cellsData = getCells(currentDate, firstDayOfWeek, 1, Date.now());
      return React.createElement("div", restProps, React.createElement(Navigator, {
        currentDate: currentDate,
        textComponent: Text,
        navigationButtonComponent: NavigationButton,
        onNavigate: this.onNavigate,
        formatDate: formatDate
      }), React.createElement(Table, {
        headerCells: cellsData[0],
        selectedDate: selectedDateState,
        cells: cellsData,
        rowComponent: Row,
        cellComponent: Cell,
        headerRowComponent: HeaderRow,
        headerCellComponent: HeaderCell,
        onCellClick: this.onCellClick,
        formatDate: formatDate
      }));
    }
  }]);

  return Root;
}(React.PureComponent);
process.env.NODE_ENV !== "production" ? Root$2.propTypes = {
  // oneOfType is a workaround because withStyles returns react object
  textComponent: PropTypes.oneOfType([PropTypes.func, PropTypes.object]).isRequired,
  navigationButtonComponent: PropTypes.oneOfType([PropTypes.func, PropTypes.object]).isRequired,
  headerRowComponent: PropTypes.oneOfType([PropTypes.func, PropTypes.object]).isRequired,
  headerCellComponent: PropTypes.oneOfType([PropTypes.func, PropTypes.object]).isRequired,
  navigatorComponent: PropTypes.oneOfType([PropTypes.func, PropTypes.object]).isRequired,
  rowComponent: PropTypes.oneOfType([PropTypes.func, PropTypes.object]).isRequired,
  cellComponent: PropTypes.oneOfType([PropTypes.func, PropTypes.object]).isRequired,
  getCells: PropTypes.func.isRequired,
  selectedDate: PropTypes.oneOfType([PropTypes.number, PropTypes.string, PropTypes.instanceOf(Date)]).isRequired,
  formatDate: PropTypes.func.isRequired,
  firstDayOfWeek: PropTypes.number,
  onSelectedDateChange: PropTypes.func
} : void 0;
Root$2.defaultProps = {
  onSelectedDateChange: function onSelectedDateChange() {},
  firstDayOfWeek: 0
};

var styles$m = function styles(_ref) {
  var palette = _ref.palette,
      spacing = _ref.spacing;
  return {
    cell: {
      userSelect: 'none',
      border: 'none',
      cursor: 'pointer',
      padding: 0,
      height: spacing(6),
      textAlign: 'center',
      verticalAlign: 'middle',
      '&:last-child': {
        padding: 0
      }
    },
    otherMonth: {
      color: palette.text.disabled
    },
    selected: {
      background: palette.primary.main,
      color: palette.primary.contrastText,
      display: 'inline-block',
      width: '2.3em',
      lineHeight: 2.3,
      borderRadius: '50%',
      cursor: 'default'
    },
    today: {
      color: palette.primary.main,
      fontWeight: 'bold'
    }
  };
};

var CellBase$5 = function CellBase(_ref2) {
  var _classNames, _classNames2;

  var otherMonth = _ref2.otherMonth,
      selected = _ref2.selected,
      today = _ref2.today,
      classes = _ref2.classes,
      children = _ref2.children,
      className = _ref2.className,
      restProps = _objectWithoutProperties(_ref2, ["otherMonth", "selected", "today", "classes", "children", "className"]);

  return React.createElement(TableCell, _extends({
    className: classNames((_classNames = {}, _defineProperty(_classNames, classes.cell, true), _defineProperty(_classNames, classes.otherMonth, otherMonth), _classNames), className)
  }, restProps), React.createElement("span", {
    className: classNames((_classNames2 = {}, _defineProperty(_classNames2, classes.selected, selected), _defineProperty(_classNames2, classes.today, today && !selected), _classNames2))
  }, children));
};

process.env.NODE_ENV !== "production" ? CellBase$5.propTypes = {
  children: PropTypes.node,
  otherMonth: PropTypes.bool,
  selected: PropTypes.bool,
  today: PropTypes.bool,
  classes: PropTypes.object.isRequired,
  className: PropTypes.string
} : void 0;
CellBase$5.defaultProps = {
  children: undefined,
  otherMonth: false,
  selected: false,
  today: false,
  className: undefined
};
var Cell$5 = styles$J.withStyles(styles$m, {
  name: 'Cell'
})(CellBase$5);

var styles$n = {
  cell: {
    userSelect: 'none',
    border: 'none',
    padding: 0,
    textAlign: 'center',
    verticalAlign: 'middle',
    '&:last-child': {
      padding: 0
    }
  }
};

var HeaderCellBase = function HeaderCellBase(_ref) {
  var classes = _ref.classes,
      children = _ref.children,
      className = _ref.className,
      restProps = _objectWithoutProperties(_ref, ["classes", "children", "className"]);

  return React.createElement(TableCell, _extends({
    className: classNames(_defineProperty({}, classes.cell, true), className)
  }, restProps), children);
};

process.env.NODE_ENV !== "production" ? HeaderCellBase.propTypes = {
  children: PropTypes.node,
  classes: PropTypes.object.isRequired,
  className: PropTypes.string
} : void 0;
HeaderCellBase.defaultProps = {
  children: undefined,
  className: undefined
};
var HeaderCell = styles$J.withStyles(styles$n, {
  name: 'HeaderCell'
})(HeaderCellBase);

var Row$1 = function Row(_ref) {
  var children = _ref.children,
      restProps = _objectWithoutProperties(_ref, ["children"]);

  return React.createElement(TableRow, restProps, children);
};
process.env.NODE_ENV !== "production" ? Row$1.propTypes = {
  children: PropTypes.node.isRequired
} : void 0;

var styles$o = {
  navigator: {
    paddingLeft: 0,
    paddingRight: 0
  }
};

var NavigatorBase = function NavigatorBase(_ref) {
  var classes = _ref.classes,
      className = _ref.className,
      currentDate = _ref.currentDate,
      Text = _ref.textComponent,
      NavigationButton = _ref.navigationButtonComponent,
      onNavigate = _ref.onNavigate,
      formatDate = _ref.formatDate,
      restProps = _objectWithoutProperties(_ref, ["classes", "className", "currentDate", "textComponent", "navigationButtonComponent", "onNavigate", "formatDate"]);

  return React.createElement(ToolbarMUI, _extends({
    className: classNames(classes.navigator, className)
  }, restProps), React.createElement(NavigationButton, {
    type: "back",
    onClick: function onClick() {
      onNavigate({
        back: true
      });
    }
  }), React.createElement(Text, {
    currentDate: currentDate,
    formatDate: formatDate
  }), React.createElement(NavigationButton, {
    type: "forward",
    onClick: function onClick() {
      onNavigate({
        back: false
      });
    }
  }));
};

process.env.NODE_ENV !== "production" ? NavigatorBase.propTypes = {
  // oneOfType is a workaround because withStyles returns react object
  classes: PropTypes.object.isRequired,
  textComponent: PropTypes.oneOfType([PropTypes.func, PropTypes.object]).isRequired,
  navigationButtonComponent: PropTypes.oneOfType([PropTypes.func, PropTypes.object]).isRequired,
  currentDate: PropTypes.oneOfType([PropTypes.number, PropTypes.string, PropTypes.instanceOf(Date)]).isRequired,
  formatDate: PropTypes.func.isRequired,
  className: PropTypes.string,
  onNavigate: PropTypes.func
} : void 0;
NavigatorBase.defaultProps = {
  className: undefined,
  onNavigate: function onNavigate() {}
};
var Navigator = styles$J.withStyles(styles$o, {
  name: 'Navigator'
})(NavigatorBase);

var styles$p = {
  text: {
    userSelect: 'none',
    flex: 1,
    textAlign: 'center'
  }
};

var TextBase = function TextBase(_ref) {
  var classes = _ref.classes,
      className = _ref.className,
      currentDate = _ref.currentDate,
      formatDate = _ref.formatDate,
      restProps = _objectWithoutProperties(_ref, ["classes", "className", "currentDate", "formatDate"]);

  return React.createElement(Typography, _extends({
    variant: "h6",
    className: classNames(_defineProperty({}, classes.text, true), className)
  }, restProps), formatDate(currentDate, dxSchedulerCore.MONTH_YEAR_OPTIONS));
};

process.env.NODE_ENV !== "production" ? TextBase.propTypes = {
  classes: PropTypes.object.isRequired,
  currentDate: PropTypes.oneOfType([PropTypes.number, PropTypes.string, PropTypes.instanceOf(Date)]).isRequired,
  formatDate: PropTypes.func.isRequired,
  className: PropTypes.string
} : void 0;
TextBase.defaultProps = {
  className: undefined
};
var Text = styles$J.withStyles(styles$p, {
  name: 'Text'
})(TextBase);

var DateNavigator = dxReactCore.withComponents({
  Root: Root$1,
  OpenButton: OpenButton,
  Overlay: Overlay,
  NavigationButton: NavigationButton,
  Calendar: Root$2,
  CalendarNavigator: Navigator,
  CalendarCell: Cell$5,
  CalendarRow: Row$1,
  CalendarHeaderCell: HeaderCell,
  CalendarHeaderRow: Row$1,
  CalendarText: Text,
  CalendarNavigationButton: NavigationButton
})(dxReactScheduler.DateNavigator);

var verticalTopHorizontalCenterOptions = {
  vertical: 'top',
  horizontal: 'center'
};

var styles$q = function styles(theme) {
  return {
    text: _objectSpread2({}, theme.typography.body2, {
      display: 'inline-block'
    }),
    title: _objectSpread2({}, theme.typography.h6, {
      paddingBottom: theme.spacing(1.75),
      color: theme.palette.primary.contrastText,
      overflow: 'hidden',
      textOverflow: 'ellipsis',
      whiteSpace: 'nowrap'
    }),
    buttonsLeft: {
      position: 'relative',
      bottom: -theme.spacing(2.5),
      textAlign: 'center'
    },
    buttonsRight: {
      textAlign: 'right'
    },
    icon: {
      color: theme.typography.body2.color
    },
    textCenter: {
      textAlign: 'center'
    }
  };
};

var LayoutBase$5 = function LayoutBase(_ref) {
  var Header = _ref.headerComponent,
      Content = _ref.contentComponent,
      CommandButton = _ref.commandButtonComponent,
      appointmentMeta = _ref.appointmentMeta,
      showOpenButton = _ref.showOpenButton,
      showCloseButton = _ref.showCloseButton,
      showDeleteButton = _ref.showDeleteButton,
      visible = _ref.visible,
      onHide = _ref.onHide,
      commandButtonIds = _ref.commandButtonIds,
      onOpenButtonClick = _ref.onOpenButtonClick,
      onDeleteButtonClick = _ref.onDeleteButtonClick,
      formatDate = _ref.formatDate,
      classes = _ref.classes,
      restProps = _objectWithoutProperties(_ref, ["headerComponent", "contentComponent", "commandButtonComponent", "appointmentMeta", "showOpenButton", "showCloseButton", "showDeleteButton", "visible", "onHide", "commandButtonIds", "onOpenButtonClick", "onDeleteButtonClick", "formatDate", "classes"]);

  var target = appointmentMeta.target,
      _appointmentMeta$data = appointmentMeta.data,
      data = _appointmentMeta$data === void 0 ? {} : _appointmentMeta$data;

  var openButtonClickHandler = function openButtonClickHandler() {
    onHide();
    onOpenButtonClick();
  };

  return React.createElement(Popover, _extends({
    open: visible,
    anchorEl: target,
    onClose: onHide,
    anchorOrigin: verticalTopHorizontalCenterOptions,
    transformOrigin: verticalTopHorizontalCenterOptions
  }, restProps), React.createElement(Header, {
    appointmentData: data
  }, React.createElement("div", {
    className: classes.buttonsRight
  }, showDeleteButton && React.createElement(CommandButton, {
    id: commandButtonIds.delete,
    onExecute: onDeleteButtonClick
  }), showCloseButton && React.createElement(CommandButton, {
    id: commandButtonIds.close,
    onExecute: onHide
  })), React.createElement(Grid, {
    container: true,
    spacing: 1,
    alignItems: "center"
  }, React.createElement(Grid, {
    item: true,
    xs: 2,
    className: classes.flexItem
  }, React.createElement("div", {
    className: classes.buttonsLeft
  }, showOpenButton && React.createElement(CommandButton, {
    id: commandButtonIds.open,
    onExecute: openButtonClickHandler
  }))), React.createElement(Grid, {
    item: true,
    xs: 10
  }, React.createElement("div", {
    className: classes.title
  }, data.title)))), React.createElement(Content, {
    appointmentData: data
  }, React.createElement(Grid, {
    container: true,
    spacing: 1,
    alignItems: "center"
  }, React.createElement(Grid, {
    item: true,
    xs: 2,
    className: classes.textCenter
  }, React.createElement(AccessTime, {
    className: classes.icon
  })), React.createElement(Grid, {
    item: true,
    xs: 10
  }, React.createElement("div", {
    className: classes.text
  }, "".concat(formatDate(data.startDate, dxSchedulerCore.HOUR_MINUTE_OPTIONS), " - ").concat(formatDate(data.endDate, dxSchedulerCore.HOUR_MINUTE_OPTIONS)))))));
};

process.env.NODE_ENV !== "production" ? LayoutBase$5.propTypes = {
  // oneOfType is a workaround because withStyles returns react object
  commandButtonComponent: PropTypes.oneOfType([PropTypes.func, PropTypes.object]).isRequired,
  headerComponent: PropTypes.oneOfType([PropTypes.func, PropTypes.object]).isRequired,
  contentComponent: PropTypes.oneOfType([PropTypes.func, PropTypes.object]).isRequired,
  showOpenButton: PropTypes.bool.isRequired,
  showCloseButton: PropTypes.bool.isRequired,
  showDeleteButton: PropTypes.bool.isRequired,
  commandButtonIds: PropTypes.object.isRequired,
  classes: PropTypes.object.isRequired,
  formatDate: PropTypes.func.isRequired,
  onOpenButtonClick: PropTypes.func,
  onDeleteButtonClick: PropTypes.func,
  appointmentMeta: PropTypes.shape({
    target: PropTypes.oneOfType([PropTypes.object, PropTypes.func]),
    data: PropTypes.object
  }),
  visible: PropTypes.bool,
  onHide: PropTypes.func
} : void 0;
LayoutBase$5.defaultProps = {
  onOpenButtonClick: function onOpenButtonClick() {
    return undefined;
  },
  onDeleteButtonClick: function onDeleteButtonClick() {
    return undefined;
  },
  onHide: function onHide() {
    return undefined;
  },
  appointmentMeta: {},
  visible: false
};
var Layout$4 = styles$J.withStyles(styles$q, {
  name: 'Layout'
})(LayoutBase$5);

var styles$r = function styles(theme) {
  return {
    head: {
      backgroundColor: theme.palette.primary.main,
      width: '300px',
      display: 'flex',
      flexDirection: 'column',
      position: 'relative',
      paddingLeft: theme.spacing(1),
      paddingRight: theme.spacing(1)
    }
  };
};

var HeaderBase = function HeaderBase(_ref) {
  var appointmentData = _ref.appointmentData,
      classes = _ref.classes,
      className = _ref.className,
      children = _ref.children,
      restProps = _objectWithoutProperties(_ref, ["appointmentData", "classes", "className", "children"]);

  return React.createElement("div", _extends({
    className: classNames(classes.head, className)
  }, restProps), children);
};

process.env.NODE_ENV !== "production" ? HeaderBase.propTypes = {
  classes: PropTypes.object.isRequired,
  appointmentData: PropTypes.object,
  children: PropTypes.node,
  className: PropTypes.string
} : void 0;
HeaderBase.defaultProps = {
  appointmentData: undefined,
  className: undefined,
  children: undefined
};
var Header = styles$J.withStyles(styles$r, {
  name: 'Header'
})(HeaderBase);

var styles$s = function styles(theme) {
  return {
    content: {
      padding: theme.spacing(3, 1),
      backgroundColor: theme.palette.background.paper
    },
    text: _objectSpread2({}, theme.typography.body2, {
      display: 'inline-block'
    })
  };
};

var ContentBase = function ContentBase(_ref) {
  var classes = _ref.classes,
      className = _ref.className,
      children = _ref.children,
      appointmentData = _ref.appointmentData,
      restProps = _objectWithoutProperties(_ref, ["classes", "className", "children", "appointmentData"]);

  return React.createElement("div", _extends({
    className: classNames(classes.content, className)
  }, restProps), children);
};
process.env.NODE_ENV !== "production" ? ContentBase.propTypes = {
  classes: PropTypes.object.isRequired,
  appointmentData: PropTypes.object,
  children: PropTypes.node,
  className: PropTypes.string
} : void 0;
ContentBase.defaultProps = {
  appointmentData: undefined,
  className: undefined,
  children: undefined
};
var Content = styles$J.withStyles(styles$s, {
  name: 'Content'
})(ContentBase);

var styles$t = function styles(_ref) {
  var palette = _ref.palette;
  return {
    button: {
      color: palette.primary.contrastText
    },
    floatButton: {
      backgroundColor: colorManipulator.lighten(palette.primary.main, 0.15)
    }
  };
};

var getIcon = function getIcon(id) {
  if (id === dxSchedulerCore.OPEN_COMMAND_BUTTON) {
    return React.createElement(EditIcon, null);
  }

  if (id === dxSchedulerCore.CLOSE_COMMAND_BUTTON) {
    return React.createElement(CloseIcon, null);
  }

  if (id === dxSchedulerCore.DELETE_COMMAND_BUTTON) {
    return React.createElement(DeleteIcon, null);
  }

  return null;
};

var CommandButtonBase = function CommandButtonBase(_ref2) {
  var classes = _ref2.classes,
      className = _ref2.className,
      id = _ref2.id,
      onExecute = _ref2.onExecute,
      restProps = _objectWithoutProperties(_ref2, ["classes", "className", "id", "onExecute"]);

  var isOpenCommandButton = id === dxSchedulerCore.OPEN_COMMAND_BUTTON;
  var buttonClass = classes[isOpenCommandButton ? 'floatButton' : 'button'];

  var commonProps = _objectSpread2({
    onClick: onExecute,
    className: classNames(buttonClass, className)
  }, restProps);

  return isOpenCommandButton ? React.createElement(Fab, _extends({
    color: "primary",
    size: "small"
  }, commonProps), getIcon(id)) : React.createElement(IconButton, commonProps, getIcon(id));
};
process.env.NODE_ENV !== "production" ? CommandButtonBase.propTypes = {
  classes: PropTypes.object.isRequired,
  id: PropTypes.string,
  className: PropTypes.string,
  onExecute: PropTypes.func
} : void 0;
CommandButtonBase.defaultProps = {
  className: undefined,
  onExecute: function onExecute() {
    return undefined;
  },
  id: ''
};
var CommandButton = styles$J.withStyles(styles$t, {
  name: 'CommandButton'
})(CommandButtonBase);

var AppointmentTooltip = dxReactCore.withComponents({
  Layout: Layout$4,
  Header: Header,
  Content: Content,
  CommandButton: CommandButton
})(dxReactScheduler.AppointmentTooltip);

var styles$u = function styles(_ref) {
  var spacing = _ref.spacing,
      typography = _ref.typography;
  return {
    root: {
      fontSize: typography.fontSize
    },
    input: {
      padding: spacing(1.25, 1.75),
      paddingRight: spacing(4),
      textTransform: 'uppercase'
    },
    menuItem: {
      fontSize: typography.fontSize,
      textTransform: 'uppercase'
    },
    inputRoot: {
      marginLeft: spacing(0.5),
      '&:first-child': {
        marginLeft: 0
      }
    }
  };
};

var SwitcherBase = React.memo(function (_ref2) {
  var currentView = _ref2.currentView,
      availableViews = _ref2.availableViews,
      onChange = _ref2.onChange,
      classes = _ref2.classes,
      restProps = _objectWithoutProperties(_ref2, ["currentView", "availableViews", "onChange", "classes"]);

  var handleChange = function handleChange(event) {
    onChange(event.target.value);
  };

  return React.createElement(Select, _extends({
    classes: {
      root: classes.root
    },
    value: currentView.name,
    onChange: handleChange,
    input: React.createElement(OutlinedInput, {
      classes: {
        input: classes.input,
        root: classes.inputRoot
      },
      labelWidth: 0
    })
  }, restProps), availableViews.map(function (_ref3) {
    var name = _ref3.name,
        displayName = _ref3.displayName;
    return React.createElement(MenuItem, {
      value: name,
      key: name,
      className: classes.menuItem
    }, displayName);
  }));
});
process.env.NODE_ENV !== "production" ? SwitcherBase.propTypes = {
  onChange: PropTypes.func.isRequired,
  classes: PropTypes.object.isRequired,
  currentView: PropTypes.shape({
    name: PropTypes.string.isRequired,
    displayName: PropTypes.string.isRequired
  }).isRequired,
  availableViews: PropTypes.arrayOf(PropTypes.shape({
    name: PropTypes.string.isRequired,
    displayName: PropTypes.string.isRequired
  }))
} : void 0;
SwitcherBase.defaultProps = {
  availableViews: []
};
var Switcher = styles$J.withStyles(styles$u)(SwitcherBase, {
  name: 'Switcher'
});

var ViewSwitcher = dxReactCore.withComponents({
  Switcher: Switcher
})(dxReactScheduler.ViewSwitcher);

var styles$v = {
  table: {
    tableLayout: 'fixed'
  }
};

var LayoutBase$6 =
/*#__PURE__*/
function (_React$PureComponent) {
  _inherits(LayoutBase, _React$PureComponent);

  function LayoutBase(props) {
    var _this;

    _classCallCheck(this, LayoutBase);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(LayoutBase).call(this, props));
    _this.table = React.createRef();
    return _this;
  }

  _createClass(LayoutBase, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      this.setCells();
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate() {
      this.setCells();
    }
  }, {
    key: "setCells",
    value: function setCells() {
      var setCellElementsMeta = this.props.setCellElementsMeta;
      var tableElement = this.table.current;
      setCellElementsMeta(cellsMeta(tableElement));
    }
  }, {
    key: "render",
    value: function render() {
      var _this$props = this.props,
          setCellElementsMeta = _this$props.setCellElementsMeta,
          cellsData = _this$props.cellsData,
          classes = _this$props.classes,
          className = _this$props.className,
          Cell = _this$props.cellComponent,
          Row = _this$props.rowComponent,
          formatDate = _this$props.formatDate,
          restProps = _objectWithoutProperties(_this$props, ["setCellElementsMeta", "cellsData", "classes", "className", "cellComponent", "rowComponent", "formatDate"]);

      return React.createElement(TableMUI, _extends({
        ref: this.table,
        className: classNames(classes.table, className)
      }, restProps), React.createElement(TableBody, null, React.createElement(Row, null, cellsData.map(function (_ref) {
        var startDate = _ref.startDate,
            endDate = _ref.endDate;
        return React.createElement(Cell, {
          key: startDate,
          startDate: startDate,
          endDate: endDate
        });
      }))));
    }
  }]);

  return LayoutBase;
}(React.PureComponent);

process.env.NODE_ENV !== "production" ? LayoutBase$6.propTypes = {
  classes: PropTypes.object.isRequired,
  formatDate: PropTypes.func.isRequired,
  cellsData: PropTypes.arrayOf(Array).isRequired,
  cellComponent: PropTypes.func.isRequired,
  rowComponent: PropTypes.func.isRequired,
  setCellElementsMeta: PropTypes.func.isRequired,
  className: PropTypes.string
} : void 0;
LayoutBase$6.defaultProps = {
  className: undefined
};
var Layout$5 = styles$J.withStyles(styles$v, {
  name: 'Layout'
})(LayoutBase$6);

var styles$w = function styles(theme) {
  return {
    cell: {
      padding: 0,
      height: theme.spacing(7),
      borderLeft: getBorder(theme),
      '&:hover': {
        backgroundColor: theme.palette.action.hover
      },
      '&:focus': {
        backgroundColor: colorManipulator.fade(theme.palette.primary.main, 0.15),
        outline: 0
      }
    }
  };
};

var CellBase$6 = function CellBase(_ref) {
  var classes = _ref.classes,
      className = _ref.className,
      children = _ref.children,
      startDate = _ref.startDate,
      endDate = _ref.endDate,
      restProps = _objectWithoutProperties(_ref, ["classes", "className", "children", "startDate", "endDate"]);

  return React.createElement(TableCell, _extends({
    tabIndex: 0,
    className: classNames(classes.cell, className)
  }, restProps), children);
};

process.env.NODE_ENV !== "production" ? CellBase$6.propTypes = {
  classes: PropTypes.object.isRequired,
  startDate: PropTypes.instanceOf(Date),
  endDate: PropTypes.instanceOf(Date),
  children: PropTypes.node,
  className: PropTypes.string
} : void 0;
CellBase$6.defaultProps = {
  children: null,
  startDate: undefined,
  endDate: undefined,
  className: undefined
};
var Cell$6 = styles$J.withStyles(styles$w, {
  name: 'Cell'
})(CellBase$6);

var styles$x = function styles(theme) {
  return {
    container: {
      userSelect: 'none',
      height: '100%',
      display: 'flex',
      flexDirection: 'column',
      justifyContent: 'flex-end',
      position: 'relative'
    },
    content: {
      borderTop: getBorder(theme),
      borderBottom: getBorder(theme),
      height: theme.spacing(7),
      textAlign: 'right',
      display: 'flex',
      alignItems: 'center',
      justifyContent: 'flex-end'
    },
    title: _objectSpread2({
      padding: theme.spacing(1)
    }, theme.typography.caption)
  };
};

var TitleCellBase = React.memo(function (_ref) {
  var classes = _ref.classes,
      getMessage = _ref.getMessage,
      className = _ref.className,
      restProps = _objectWithoutProperties(_ref, ["classes", "getMessage", "className"]);

  return React.createElement("div", _extends({
    className: classNames(classes.container, className)
  }, restProps), React.createElement("div", {
    className: classes.content
  }, React.createElement(Typography, {
    className: classes.title,
    variant: "body1"
  }, getMessage('allDay'))));
});
TitleCellBase.propTypes = {
  classes: PropTypes.object.isRequired,
  getMessage: PropTypes.func.isRequired,
  className: PropTypes.string
};
TitleCellBase.defaultProps = {
  className: undefined
};
var TitleCell = styles$J.withStyles(styles$x, {
  name: 'TitleCell'
})(TitleCellBase);

var styles$y = {
  container: {
    position: 'relative'
  }
};
var Container$1 = styles$J.withStyles(styles$y, {
  name: 'AllDayContainer'
})(ContainerBase);

var AllDayPanel = dxReactCore.withComponents({
  AppointmentLayer: Container,
  Layout: Layout$5,
  Cell: Cell$6,
  Row: Row,
  TitleCell: TitleCell,
  Container: Container$1
})(dxReactScheduler.AllDayPanel);

var Popup = function Popup(_ref) {
  var children = _ref.children,
      visible = _ref.visible,
      restProps = _objectWithoutProperties(_ref, ["children", "visible"]);

  return React.createElement(Modal, _extends({
    open: visible
  }, restProps), children);
};
process.env.NODE_ENV !== "production" ? Popup.propTypes = {
  children: PropTypes.node.isRequired,
  visible: PropTypes.bool
} : void 0;
Popup.defaultProps = {
  visible: false
};

var CommandButton$1 = function CommandButton(_ref) {
  var text = _ref.text,
      readOnly = _ref.readOnly,
      onExecute = _ref.onExecute,
      id = _ref.id,
      restProps = _objectWithoutProperties(_ref, ["text", "readOnly", "onExecute", "id"]);

  return React.createElement(Button$1, _extends({
    color: "primary",
    disabled: readOnly,
    onClick: onExecute
  }, restProps), text);
};
process.env.NODE_ENV !== "production" ? CommandButton$1.propTypes = {
  text: PropTypes.string.isRequired,
  onExecute: PropTypes.func.isRequired,
  id: PropTypes.string.isRequired,
  readOnly: PropTypes.bool
} : void 0;
CommandButton$1.defaultProps = {
  readOnly: false
};

var styles$z = {
  editor: {
    width: '100%',
    '&:first-child': {
      marginTop: 0
    }
  }
};

var TextEditorBase = function TextEditorBase(_ref) {
  var classes = _ref.classes,
      value = _ref.value,
      label = _ref.label,
      className = _ref.className,
      readOnly = _ref.readOnly,
      onValueChange = _ref.onValueChange,
      restProps = _objectWithoutProperties(_ref, ["classes", "value", "label", "className", "readOnly", "onValueChange"]);

  return React.createElement(TextField, _extends({
    label: label,
    className: classNames(classes.editor, className),
    value: value,
    margin: "normal",
    variant: "filled",
    disabled: readOnly,
    onChange: function onChange(_ref2) {
      var target = _ref2.target;
      return onValueChange(target.value);
    }
  }, restProps));
};

process.env.NODE_ENV !== "production" ? TextEditorBase.propTypes = {
  classes: PropTypes.object.isRequired,
  value: PropTypes.string,
  label: PropTypes.string,
  className: PropTypes.string,
  readOnly: PropTypes.bool,
  onValueChange: PropTypes.func
} : void 0;
TextEditorBase.defaultProps = {
  value: '',
  label: undefined,
  className: undefined,
  readOnly: false,
  onValueChange: function onValueChange() {
    return undefined;
  }
};
var TextEditor = styles$J.withStyles(styles$z)(TextEditorBase, {
  name: 'TextEditor'
});

var styles$A = function styles() {
  return {
    editor: {
      width: '100%'
    }
  };
};

var DateEditorBase = function DateEditorBase(_ref) {
  var classes = _ref.classes,
      value = _ref.value,
      label = _ref.label,
      className = _ref.className,
      readOnly = _ref.readOnly,
      onValueChange = _ref.onValueChange,
      restProps = _objectWithoutProperties(_ref, ["classes", "value", "label", "className", "readOnly", "onValueChange"]);

  return React.createElement(TextField, _extends({
    label: label,
    className: classNames(classes.editor, className),
    value: moment(value).format(moment.HTML5_FMT.DATETIME_LOCAL),
    margin: "normal",
    variant: "filled",
    type: "datetime-local",
    disabled: readOnly,
    InputLabelProps: {
      shrink: true
    },
    onChange: function onChange(_ref2) {
      var target = _ref2.target;
      return onValueChange(target.value);
    }
  }, restProps));
};

process.env.NODE_ENV !== "production" ? DateEditorBase.propTypes = {
  classes: PropTypes.object.isRequired,
  value: PropTypes.oneOfType([PropTypes.number, PropTypes.string, PropTypes.instanceOf(Date)]),
  label: PropTypes.string,
  className: PropTypes.string,
  readOnly: PropTypes.bool,
  onValueChange: PropTypes.func
} : void 0;
DateEditorBase.defaultProps = {
  value: undefined,
  label: undefined,
  className: undefined,
  readOnly: false,
  onValueChange: function onValueChange() {
    return undefined;
  }
};
var DateEditor = styles$J.withStyles(styles$A)(DateEditorBase, {
  name: 'DateEditor'
});

var BooleanEditor = function BooleanEditor(_ref) {
  var text = _ref.text,
      value = _ref.value,
      readOnly = _ref.readOnly,
      onValueChange = _ref.onValueChange,
      restProps = _objectWithoutProperties(_ref, ["text", "value", "readOnly", "onValueChange"]);

  return React.createElement(FormControlLabel, _extends({
    control: React.createElement(Checkbox, {
      color: "primary",
      checked: value,
      onChange: function onChange(_ref2) {
        var target = _ref2.target;
        return onValueChange(target.checked);
      }
    }),
    disabled: readOnly,
    label: text
  }, restProps));
};
process.env.NODE_ENV !== "production" ? BooleanEditor.propTypes = {
  text: PropTypes.string,
  readOnly: PropTypes.bool,
  value: PropTypes.bool,
  onValueChange: PropTypes.func
} : void 0;
BooleanEditor.defaultProps = {
  text: undefined,
  readOnly: false,
  value: false,
  onValueChange: function onValueChange() {
    return undefined;
  }
};

var styles$B = function styles(theme) {
  return {
    root: {
      width: theme.spacing(50),
      padding: theme.spacing(1),
      margin: '0 auto',
      transform: 'translateY(20%)',
      msTransform: 'translateY(20%)'
    }
  };
};

var ContainerBase$1 = function ContainerBase(_ref) {
  var children = _ref.children,
      classes = _ref.classes,
      className = _ref.className,
      restProps = _objectWithoutProperties(_ref, ["children", "classes", "className"]);

  return React.createElement(Paper, _extends({
    className: classNames(classes.root, className)
  }, restProps), children);
};

process.env.NODE_ENV !== "production" ? ContainerBase$1.propTypes = {
  children: PropTypes.node.isRequired,
  className: PropTypes.string,
  classes: PropTypes.object.isRequired
} : void 0;
ContainerBase$1.defaultProps = {
  className: undefined
};
var Container$2 = styles$J.withStyles(styles$B)(ContainerBase$1, {
  name: 'Container'
});

var styles$C = function styles(theme) {
  return {
    root: {
      maxHeight: theme.spacing(50),
      overflowY: 'auto',
      padding: theme.spacing(2),
      paddingBottom: 0
    }
  };
};

var ScrollableAreaBase = function ScrollableAreaBase(_ref) {
  var children = _ref.children,
      classes = _ref.classes,
      className = _ref.className,
      restProps = _objectWithoutProperties(_ref, ["children", "classes", "className"]);

  return React.createElement("div", _extends({
    className: classNames(classes.root, className)
  }, restProps), children);
};

process.env.NODE_ENV !== "production" ? ScrollableAreaBase.propTypes = {
  children: PropTypes.node.isRequired,
  className: PropTypes.string,
  classes: PropTypes.object.isRequired
} : void 0;
ScrollableAreaBase.defaultProps = {
  className: undefined
};
var ScrollableArea = styles$J.withStyles(styles$C)(ScrollableAreaBase, {
  name: 'ScrollableArea'
});

var styles$D = function styles(theme) {
  return {
    root: {
      display: 'flex',
      justifyContent: 'flex-end',
      paddingTop: theme.spacing(1)
    }
  };
};

var StaticAreaBase = function StaticAreaBase(_ref) {
  var children = _ref.children,
      classes = _ref.classes,
      className = _ref.className,
      restProps = _objectWithoutProperties(_ref, ["children", "classes", "className"]);

  return React.createElement("div", _extends({
    className: classNames(classes.root, className)
  }, restProps), children);
};

process.env.NODE_ENV !== "production" ? StaticAreaBase.propTypes = {
  children: PropTypes.node.isRequired,
  classes: PropTypes.object.isRequired,
  className: PropTypes.string
} : void 0;
StaticAreaBase.defaultProps = {
  className: undefined
};
var StaticArea = styles$J.withStyles(styles$D)(StaticAreaBase, {
  name: 'StaticArea'
});

var AppointmentForm = dxReactCore.withComponents({
  Popup: Popup,
  CommandButton: CommandButton$1,
  TitleEditor: TextEditor,
  StartDateEditor: DateEditor,
  EndDateEditor: DateEditor,
  AllDayEditor: BooleanEditor,
  Container: Container$2,
  ScrollableArea: ScrollableArea,
  StaticArea: StaticArea
})(dxReactScheduler.AppointmentForm);

var draftStyles = function draftStyles(theme) {
  return {
    appointment: {
      boxShadow: theme.shadows[3],
      cursor: 'move',
      overflow: 'hidden',
      backgroundColor: setColor(600, theme.palette.primary),
      border: 0
    }
  };
};

var sourceStyles = {
  appointment: {
    opacity: 0.5
  }
};

var DraftAppointmentBase = function DraftAppointmentBase(_ref) {
  var classes = _ref.classes,
      className = _ref.className,
      data = _ref.data,
      formatDate = _ref.formatDate,
      type = _ref.type,
      fromPrev = _ref.fromPrev,
      toNext = _ref.toNext,
      restProps = _objectWithoutProperties(_ref, ["classes", "className", "data", "formatDate", "type", "fromPrev", "toNext"]);

  return React.createElement(Appointment, _extends({
    className: classNames(classes.appointment, className),
    type: type
  }, restProps), fromPrev && React.createElement(SplitIndicator, {
    position: dxSchedulerCore.POSITION_START,
    appointmentType: type
  }), React.createElement(AppointmentContent, {
    data: data,
    type: type,
    recurringIconComponent: Repeat,
    formatDate: formatDate
  }), toNext && React.createElement(SplitIndicator, {
    position: dxSchedulerCore.POSITION_END,
    appointmentType: type
  }));
};

process.env.NODE_ENV !== "production" ? DraftAppointmentBase.propTypes = {
  classes: PropTypes.object.isRequired,
  data: PropTypes.object.isRequired,
  fromPrev: PropTypes.bool.isRequired,
  toNext: PropTypes.bool.isRequired,
  formatDate: PropTypes.func.isRequired,
  className: PropTypes.string,
  type: PropTypes.string
} : void 0;
DraftAppointmentBase.defaultProps = {
  className: undefined,
  type: undefined
};
var DraftAppointment = styles$J.withStyles(draftStyles, {
  name: 'DraftAppointment'
})(DraftAppointmentBase);
var SourceAppointment = styles$J.withStyles(sourceStyles, {
  name: 'SourceAppointment'
})(DraftAppointmentBase);

var styles$E = {
  container: {
    position: 'absolute',
    left: 0,
    top: 0,
    height: '100%',
    width: '100%',
    cursor: 'move'
  }
};
var Container$3 = styles$J.withStyles(styles$E, {
  name: 'DragDropContainer'
})(ContainerBase);

var verticalStyles$1 = function verticalStyles(spacing) {
  return {
    width: '100%',
    height: spacing(1),
    cursor: 'ns-resize'
  };
};

var horizontalStyles$1 = function horizontalStyles(spacing) {
  return {
    width: spacing(1),
    height: '100%',
    cursor: 'ew-resize'
  };
};

var styles$F = function styles(_ref) {
  var spacing = _ref.spacing;
  var vertical = verticalStyles$1(spacing);
  var horizontal = horizontalStyles$1(spacing);
  return {
    resize: {
      position: 'absolute',
      zIndex: 100
    },
    verticalStart: _objectSpread2({}, vertical, {
      top: 0
    }),
    verticalEnd: _objectSpread2({}, vertical, {
      bottom: 0
    }),
    horizontalStart: _objectSpread2({}, horizontal, {
      left: 0
    }),
    horizontalEnd: _objectSpread2({}, horizontal, {
      right: 0
    })
  };
};

var ResizeBase = React.memo(function (_ref2) {
  var _classNames;

  var classes = _ref2.classes,
      className = _ref2.className,
      position = _ref2.position,
      appointmentType = _ref2.appointmentType,
      restProps = _objectWithoutProperties(_ref2, ["classes", "className", "position", "appointmentType"]);

  var vertical = appointmentType === dxSchedulerCore.VERTICAL_TYPE;
  var start = position === dxSchedulerCore.POSITION_START;
  return React.createElement("div", _extends({
    className: classNames((_classNames = {}, _defineProperty(_classNames, classes.resize, true), _defineProperty(_classNames, classes.verticalStart, vertical && start), _defineProperty(_classNames, classes.verticalEnd, vertical && !start), _defineProperty(_classNames, classes.horizontalStart, !vertical && start), _defineProperty(_classNames, classes.horizontalEnd, !vertical && !start), _classNames), className)
  }, restProps));
});
process.env.NODE_ENV !== "production" ? ResizeBase.propTypes = {
  classes: PropTypes.object.isRequired,
  position: PropTypes.oneOf([dxSchedulerCore.POSITION_START, dxSchedulerCore.POSITION_END]).isRequired,
  appointmentType: PropTypes.oneOf([dxSchedulerCore.HORIZONTAL_TYPE, dxSchedulerCore.VERTICAL_TYPE]).isRequired,
  className: PropTypes.string
} : void 0;
ResizeBase.defaultProps = {
  className: undefined
};
var Resize = styles$J.withStyles(styles$F, {
  name: 'Resize'
})(ResizeBase);

var DragDropProvider = dxReactCore.withComponents({
  DraftAppointment: DraftAppointment,
  SourceAppointment: SourceAppointment,
  Container: Container$3,
  Resize: Resize
})(dxReactScheduler.DragDropProvider);

var styles$G = function styles(_ref) {
  var spacing = _ref.spacing;
  return {
    button: {
      padding: spacing(0.8, 2),
      marginLeft: spacing(0.5),
      '&:first-child': {
        marginLeft: 0
      }
    }
  };
};

var TodayButtonBase = function TodayButtonBase(_ref2) {
  var setCurrentDate = _ref2.setCurrentDate,
      classes = _ref2.classes,
      getMessage = _ref2.getMessage,
      className = _ref2.className,
      restProps = _objectWithoutProperties(_ref2, ["setCurrentDate", "classes", "getMessage", "className"]);

  var handleClick = function handleClick() {
    setCurrentDate(new Date());
  };

  return React.createElement(Button$1, _extends({
    className: classNames(classes.button, className),
    variant: "outlined",
    onClick: handleClick
  }, restProps), getMessage('today'));
};

process.env.NODE_ENV !== "production" ? TodayButtonBase.propTypes = {
  setCurrentDate: PropTypes.func.isRequired,
  classes: PropTypes.object.isRequired,
  className: PropTypes.string,
  getMessage: PropTypes.func.isRequired
} : void 0;
TodayButtonBase.defaultProps = {
  className: undefined
};
var TodayButton = styles$J.withStyles(styles$G)(TodayButtonBase, {
  name: 'TodayButton'
});

var TodayButton$1 = dxReactCore.withComponents({
  Button: TodayButton
})(dxReactScheduler.TodayButton);

var styles$H = {
  modal: {
    position: 'absolute!important'
  }
};

var OverlayBase = function OverlayBase(_ref) {
  var children = _ref.children,
      visible = _ref.visible,
      onHide = _ref.onHide,
      target = _ref.target,
      classes = _ref.classes,
      className = _ref.className,
      restProps = _objectWithoutProperties(_ref, ["children", "visible", "onHide", "target", "classes", "className"]);

  return React.createElement(Dialog, _extends({
    open: visible,
    onClose: onHide,
    className: classNames(classes.modal, className),
    BackdropProps: {
      className: classes.modal
    },
    container: target.current,
    onBackdropClick: onHide
  }, restProps), children);
};

process.env.NODE_ENV !== "production" ? OverlayBase.propTypes = {
  children: PropTypes.node.isRequired,
  classes: PropTypes.object.isRequired,
  onHide: PropTypes.func.isRequired,
  target: PropTypes.object.isRequired,
  visible: PropTypes.bool,
  className: PropTypes.string
} : void 0;
OverlayBase.defaultProps = {
  className: undefined,
  visible: false
};
var Overlay$1 = styles$J.withStyles(styles$H, {
  name: 'Overlay'
})(OverlayBase);

var Layout$6 = React.memo(function (_ref) {
  var Button = _ref.buttonComponent,
      handleClose = _ref.handleClose,
      commit = _ref.commit,
      availableOperations = _ref.availableOperations,
      getMessage = _ref.getMessage,
      isDeleting = _ref.isDeleting,
      restProps = _objectWithoutProperties(_ref, ["buttonComponent", "handleClose", "commit", "availableOperations", "getMessage", "isDeleting"]);

  var _React$useState = React.useState(availableOperations[0].value),
      _React$useState2 = _slicedToArray(_React$useState, 2),
      currentValue = _React$useState2[0],
      setCurrentValue = _React$useState2[1];

  var handleChange = React.useCallback(function (event) {
    setCurrentValue(event.target.value);
  });

  var onCommitButtonClick = function onCommitButtonClick() {
    commit(currentValue);
  };

  return React.createElement("div", restProps, React.createElement(DialogTitle, null, getMessage(isDeleting ? 'menuDeleteTitle' : 'menuEditTitle')), React.createElement(DialogContent, null, React.createElement(RadioGroup, {
    value: currentValue,
    onChange: handleChange
  }, availableOperations.map(function (operation) {
    return React.createElement(FormControlLabel, {
      value: operation.value,
      control: React.createElement(Radio, null),
      label: operation.title,
      key: operation.value
    });
  }))), React.createElement(DialogActions, null, React.createElement(Button, {
    onClick: handleClose,
    title: getMessage('cancelButton')
  }), React.createElement(Button, {
    onClick: onCommitButtonClick,
    title: getMessage('commitButton'),
    color: "primary"
  })));
});
process.env.NODE_ENV !== "production" ? Layout$6.propTypes = {
  buttonComponent: PropTypes.oneOfType([PropTypes.func, PropTypes.object]).isRequired,
  availableOperations: PropTypes.array.isRequired,
  handleClose: PropTypes.func,
  commit: PropTypes.func,
  getMessage: PropTypes.func,
  isDeleting: PropTypes.bool
} : void 0;
Layout$6.defaultProps = {
  handleClose: function handleClose() {
    return undefined;
  },
  commit: function commit() {
    return undefined;
  },
  getMessage: function getMessage() {
    return undefined;
  },
  isDeleting: false
};

var Button = function Button(_ref) {
  var onClick = _ref.onClick,
      title = _ref.title,
      restProps = _objectWithoutProperties(_ref, ["onClick", "title"]);

  return React.createElement(Button$1, _extends({
    onClick: onClick
  }, restProps), title);
};
process.env.NODE_ENV !== "production" ? Button.propTypes = {
  onClick: PropTypes.func.isRequired,
  title: PropTypes.string
} : void 0;
Button.defaultProps = {
  title: ''
};

var styles$I = {
  container: {
    position: 'absolute',
    width: '100%',
    height: '100%'
  }
};
var ContainerBase$2 = React.forwardRef(function (_ref, ref) {
  var children = _ref.children,
      classes = _ref.classes,
      className = _ref.className,
      restProps = _objectWithoutProperties(_ref, ["children", "classes", "className"]);

  return React.createElement("div", _extends({
    ref: ref,
    className: classNames(classes.container, className)
  }, restProps), children);
});
ContainerBase$2.propTypes = {
  classes: PropTypes.object.isRequired,
  children: PropTypes.node,
  className: PropTypes.string
};
ContainerBase$2.defaultProps = {
  children: null,
  className: undefined
};
var Container$4 = styles$J.withStyles(styles$I, {
  name: 'Container'
})(ContainerBase$2);

var EditRecurrenceMenu = dxReactCore.withComponents({
  Layout: Layout$6,
  Overlay: Overlay$1,
  Button: Button,
  Container: Container$4
})(dxReactScheduler.EditRecurrenceMenu);

exports.AllDayPanel = AllDayPanel;
exports.AppointmentForm = AppointmentForm;
exports.AppointmentTooltip = AppointmentTooltip;
exports.Appointments = Appointments;
exports.DateNavigator = DateNavigator;
exports.DayView = DayView;
exports.DragDropProvider = DragDropProvider;
exports.EditRecurrenceMenu = EditRecurrenceMenu;
exports.MonthView = MonthView;
exports.Scheduler = Scheduler;
exports.TodayButton = TodayButton$1;
exports.Toolbar = Toolbar$1;
exports.ViewSwitcher = ViewSwitcher;
exports.WeekView = WeekView;
//# sourceMappingURL=dx-react-scheduler-material-ui.cjs.js.map
