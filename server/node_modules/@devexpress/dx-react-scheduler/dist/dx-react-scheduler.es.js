/**
 * Bundle of @devexpress/dx-react-scheduler
 * Generated: 2019-09-16
 * Version: 2.0.5
 * License: https://js.devexpress.com/Licensing
 */

import { createElement, PureComponent, Fragment, createRef } from 'react';
import { Plugin, Getter, Template, TemplatePlaceholder, PluginHost, TemplateConnector, Action, createStateHelper, DragDropProvider as DragDropProvider$1, DropTarget, DragSource } from '@devexpress/dx-react-core';
import { formatDateTimeGetter, appointments, getAppointmentStyle, computed, viewCellsData, availableViews, verticalTimeTableRects, startViewDate, endViewDate, monthCellsData, horizontalTimeTableRects, viewBoundText, POSITION_START, POSITION_END, allDayCells, allDayRects, changeCurrentDate, setCurrentViewName, preCommitChanges, startEditAppointment, stopEditAppointment, changeAppointment, cancelChanges, RECURRENCE_EDIT_SCOPE, changedAppointmentById, addAppointment, cancelAddedAppointment, OPEN_COMMAND_BUTTON, CLOSE_COMMAND_BUTTON, DELETE_COMMAND_BUTTON, setAppointmentMeta, CANCEL_COMMAND_BUTTON, COMMIT_COMMAND_BUTTON, callActionIfExists, isAllDayCell, setAppointmentData, autoScroll, cellIndex, cellData, cellType, calculateInsidePart, intervalDuration, calculateAppointmentTimeBoundaries, calculateDraftAppointments, RESIZE_TOP, RESIZE_BOTTOM } from '@devexpress/dx-scheduler-core';
import { memoize, createClickHandlers, getMessagesFormatter } from '@devexpress/dx-core';
import moment from 'moment';

/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
/* global Reflect, Promise */

var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return extendStatics(d, b);
};

function __extends(d, b) {
    extendStatics(d, b);
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};

function __rest(s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
}

var SchedulerCoreBase = /*#__PURE__*/ (function (_super) {
    __extends(SchedulerCoreBase, _super);
    function SchedulerCoreBase() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.formatDateTimeGetter = memoize(function (locale) { return formatDateTimeGetter(locale); });
        return _this;
    }
    SchedulerCoreBase.prototype.render = function () {
        var _a = this.props, data = _a.data, Root = _a.rootComponent, locale = _a.locale, height = _a.height;
        return (createElement(Plugin, { name: "SchedulerCore" },
            createElement(Getter, { name: "appointments", value: appointments(data) }),
            createElement(Getter, { name: "formatDate", value: formatDateTimeGetter(locale) }),
            createElement(Template, { name: "root" },
                createElement(Root, { height: height },
                    createElement(TemplatePlaceholder, { name: "schedulerRoot" }),
                    createElement(TemplatePlaceholder, { name: "header" }),
                    createElement(TemplatePlaceholder, { name: "body" }),
                    createElement(TemplatePlaceholder, { name: "footer" })))));
    };
    return SchedulerCoreBase;
}(PureComponent));
/***
 * The Scheduler is a root container component designed to process
 * and display the specified data. The Scheduler's functionality
 * (data visualization and processing) is implemented in several plugins
 * specified as child components.
 * */
var SchedulerCore = SchedulerCoreBase;

var SchedulerBase = function (_a) {
    var data = _a.data, rootComponent = _a.rootComponent, children = _a.children, locale = _a.locale, height = _a.height;
    return (createElement(PluginHost, null,
        createElement(SchedulerCore, { data: data, rootComponent: rootComponent, locale: locale, height: height }),
        children));
};
SchedulerBase.defaultProps = {
    data: [],
    locale: 'en-US',
    height: 'auto',
};
// tslint:disable: max-line-length
/***
 * The Scheduler is a root container component designed to process
 * and display the specified data. The Scheduler’s functionality
 * (data visualization and processing) is implemented in several plugins specified as child components.
 * */
var Scheduler = SchedulerBase;

var TYPE = 'day';
var startViewDateBaseComputed = function (_a) {
    var viewCellsData = _a.viewCellsData;
    return startViewDate(viewCellsData);
};
var endViewDateBaseComputed = function (_a) {
    var viewCellsData = _a.viewCellsData;
    return endViewDate(viewCellsData);
};
var viewCellsDataBaseComputed = function (startDayHour, endDayHour, cellDuration) { return function (_a) {
    var currentDate = _a.currentDate, intervalCount = _a.intervalCount;
    return viewCellsData(currentDate, undefined, intervalCount, [], startDayHour, endDayHour, cellDuration, Date.now());
}; };
var CellPlaceholder = function (params) { return createElement(TemplatePlaceholder, { name: "cell", params: params }); };
var AppointmentPlaceholder = function (params) { return createElement(TemplatePlaceholder, { name: "appointment", params: params }); };
var TimeTablePlaceholder = function () { return createElement(TemplatePlaceholder, { name: "timeTable" }); };
var DayScaleEmptyCellPlaceholder = function () { return createElement(TemplatePlaceholder, { name: "dayScaleEmptyCell" }); };
var DayScalePlaceholder = function () { return createElement(TemplatePlaceholder, { name: "dayScale" }); };
var TimeScalePlaceholder = function () { return createElement(TemplatePlaceholder, { name: "timeScale" }); };
var DayViewBase = /*#__PURE__*/ (function (_super) {
    __extends(DayViewBase, _super);
    function DayViewBase() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.state = {
            rects: [],
            timeTableElementsMeta: {},
            scrollingStrategy: {
                topBoundary: 0,
                bottomBoundary: 0,
                changeVerticalScroll: function () { return undefined; },
            },
        };
        _this.scrollingStrategyComputed = memoize(function (viewName, scrollingStrategy) { return function (getters) {
            return computed(getters, viewName, function () { return scrollingStrategy; }, getters.scrollingStrategy);
        }; });
        _this.timeTableElementsMetaComputed = memoize(function (viewName, timeTableElementsMeta) { return function (getters) {
            return computed(getters, viewName, function () { return timeTableElementsMeta; }, getters.timeTableElementsMeta);
        }; });
        _this.viewCellsDataComputed = memoize(function (viewName, startDayHour, endDayHour, cellDuration) { return function (getters) {
            return computed(getters, viewName, viewCellsDataBaseComputed(startDayHour, endDayHour, cellDuration), getters.viewCellsData);
        }; });
        _this.cellDurationComputed = memoize(function (viewName, cellDuration) { return function (getters) {
            return computed(getters, viewName, function () { return cellDuration; }, getters.cellDuration);
        }; });
        _this.intervalCountComputed = memoize(function (viewName, intervalCount) { return function (getters) {
            return computed(getters, viewName, function () { return intervalCount; }, getters.intervalCount);
        }; });
        _this.availableViews = memoize(function (viewName, displayName) { return function (_a) {
            var availableViews$1 = _a.availableViews;
            return availableViews(availableViews$1, viewName, displayName);
        }; });
        _this.currentView = memoize(function (viewName, viewDisplayName) { return function (_a) {
            var currentView = _a.currentView;
            return (currentView && currentView.name !== viewName
                ? currentView
                : { name: viewName, type: TYPE, displayName: viewDisplayName });
        }; });
        _this.endViewDateComputed = function (getters) {
            var viewName = _this.props.name;
            return computed(getters, viewName, endViewDateBaseComputed, getters.endViewDate);
        };
        _this.startViewDateComputed = function (getters) {
            var viewName = _this.props.name;
            return computed(getters, viewName, startViewDateBaseComputed, getters.startViewDate);
        };
        _this.updateRects = memoize(function (appointments, startViewDate, endViewDate, viewCellsData, cellDuration, currentDate) { return function (cellElementsMeta) {
            var rects = verticalTimeTableRects(appointments, startViewDate, endViewDate, [], viewCellsData, cellDuration, cellElementsMeta);
            _this.setState({ rects: rects, timeTableElementsMeta: cellElementsMeta });
        }; });
        _this.setScrollingStrategy = function (scrollingStrategy) {
            _this.setState({ scrollingStrategy: scrollingStrategy });
        };
        return _this;
    }
    DayViewBase.prototype.render = function () {
        var _this = this;
        var _a = this.props, Layout = _a.layoutComponent, DayScaleEmptyCell = _a.dayScaleEmptyCellComponent, TimeScale = _a.timeScaleLayoutComponent, TimeScaleRow = _a.timeScaleRowComponent, TimeScaleCell = _a.timeScaleCellComponent, DayScale = _a.dayScaleLayoutComponent, DayScaleCell = _a.dayScaleCellComponent, DayScaleRow = _a.dayScaleRowComponent, TimeTableLayout = _a.timeTableLayoutComponent, timeTableRowComponent = _a.timeTableRowComponent, TimeTableCell = _a.timeTableCellComponent, AppointmentLayer = _a.appointmentLayerComponent, cellDuration = _a.cellDuration, viewName = _a.name, intervalCount = _a.intervalCount, startDayHour = _a.startDayHour, endDayHour = _a.endDayHour, displayName = _a.displayName;
        var _b = this.state, rects = _b.rects, timeTableElementsMeta = _b.timeTableElementsMeta, scrollingStrategy = _b.scrollingStrategy;
        var viewDisplayName = displayName || viewName;
        return (createElement(Plugin, { name: "DayView" },
            createElement(Getter, { name: "availableViews", computed: this.availableViews(viewName, viewDisplayName) }),
            createElement(Getter, { name: "currentView", computed: this.currentView(viewName, viewDisplayName) }),
            createElement(Getter, { name: "intervalCount", computed: this.intervalCountComputed(viewName, intervalCount) }),
            createElement(Getter, { name: "cellDuration", computed: this.cellDurationComputed(viewName, cellDuration) }),
            createElement(Getter, { name: "viewCellsData", computed: this.viewCellsDataComputed(viewName, startDayHour, endDayHour, cellDuration) }),
            createElement(Getter, { name: "startViewDate", computed: this.startViewDateComputed }),
            createElement(Getter, { name: "endViewDate", computed: this.endViewDateComputed }),
            createElement(Getter, { name: "timeTableElementsMeta", computed: this.timeTableElementsMetaComputed(viewName, timeTableElementsMeta) }),
            createElement(Getter, { name: "scrollingStrategy", computed: this.scrollingStrategyComputed(viewName, scrollingStrategy) }),
            createElement(Template, { name: "body" },
                createElement(TemplateConnector, null, function (_a) {
                    var currentView = _a.currentView;
                    if (currentView.name !== viewName)
                        return createElement(TemplatePlaceholder, null);
                    return (createElement(Layout, { dayScaleComponent: DayScalePlaceholder, dayScaleEmptyCellComponent: DayScaleEmptyCellPlaceholder, timeTableComponent: TimeTablePlaceholder, timeScaleComponent: TimeScalePlaceholder, setScrollingStrategy: _this.setScrollingStrategy }));
                })),
            createElement(Template, { name: "dayScale" },
                createElement(TemplateConnector, null, function (_a) {
                    var currentView = _a.currentView, viewCellsData = _a.viewCellsData, formatDate = _a.formatDate;
                    if (currentView.name !== viewName)
                        return createElement(TemplatePlaceholder, null);
                    return (createElement(DayScale, { cellComponent: DayScaleCell, rowComponent: DayScaleRow, cellsData: viewCellsData, formatDate: formatDate }));
                })),
            createElement(Template, { name: "dayScaleEmptyCell" },
                createElement(TemplateConnector, null, function (_a) {
                    var currentView = _a.currentView;
                    if (currentView.name !== viewName)
                        return createElement(TemplatePlaceholder, null);
                    return (createElement(DayScaleEmptyCell, null));
                })),
            createElement(Template, { name: "timeScale" },
                createElement(TemplateConnector, null, function (_a) {
                    var currentView = _a.currentView, viewCellsData = _a.viewCellsData, formatDate = _a.formatDate;
                    if (currentView.name !== viewName)
                        return createElement(TemplatePlaceholder, null);
                    return (createElement(TimeScale, { rowComponent: TimeScaleRow, cellComponent: TimeScaleCell, cellsData: viewCellsData, formatDate: formatDate }));
                })),
            createElement(Template, { name: "timeTable" },
                createElement(TemplateConnector, null, function (_a) {
                    var appointments = _a.appointments, startViewDate = _a.startViewDate, formatDate = _a.formatDate, endViewDate = _a.endViewDate, currentView = _a.currentView, currentDate = _a.currentDate, viewCellsData = _a.viewCellsData;
                    if (currentView.name !== viewName)
                        return createElement(TemplatePlaceholder, null);
                    var setRects = _this.updateRects(appointments, startViewDate, endViewDate, viewCellsData, cellDuration, currentDate);
                    return (createElement(Fragment, null,
                        createElement(TimeTableLayout, { cellsData: viewCellsData, rowComponent: timeTableRowComponent, cellComponent: CellPlaceholder, formatDate: formatDate, setCellElementsMeta: setRects }),
                        createElement(AppointmentLayer, null, rects.map(function (_a, index) {
                            var dataItem = _a.dataItem, type = _a.type, fromPrev = _a.fromPrev, toNext = _a.toNext, geometry = __rest(_a, ["dataItem", "type", "fromPrev", "toNext"]);
                            return (createElement(AppointmentPlaceholder, { key: index.toString(), type: type, data: dataItem, fromPrev: fromPrev, toNext: toNext, style: getAppointmentStyle(geometry) }));
                        }))));
                })),
            createElement(Template, { name: "cell" }, function (params) { return (createElement(TemplateConnector, null, function (_a) {
                var currentView = _a.currentView;
                if (currentView.name !== viewName)
                    return createElement(TemplatePlaceholder, { params: params });
                return (createElement(TimeTableCell, __assign({}, params)));
            })); })));
    };
    DayViewBase.defaultProps = {
        name: 'Day',
        startDayHour: 0,
        endDayHour: 24,
        cellDuration: 30,
        intervalCount: 1,
    };
    DayViewBase.components = {
        layoutComponent: 'Layout',
        layoutContainer: 'LayoutContainer',
        appointmentLayerComponent: 'AppointmentLayer',
        dayScaleEmptyCellComponent: 'DayScaleEmptyCell',
        timeScaleLayoutComponent: 'TimeScaleLayout',
        timeScaleCellComponent: 'TimeScaleCell',
        timeScaleRowComponent: 'TimeScaleRow',
        dayScaleLayoutComponent: 'DayScaleLayout',
        dayScaleCellComponent: 'DayScaleCell',
        dayScaleRowComponent: 'DayScaleRow',
        timeTableContainerComponent: 'TimeTableContainer',
        timeTableLayoutComponent: 'TimeTableLayout',
        timeTableCellComponent: 'TimeTableCell',
        timeTableRowComponent: 'TimeTableRow',
    };
    return DayViewBase;
}(PureComponent));
// tslint:disable-next-line: max-line-length
/*** A plugin that renders Scheduler data for a day. This plugin arranges appointments from top to bottom.
 * If their time intervals overlap, their width is decreased and they are placed next to each other.
 * */
var DayView = DayViewBase;

var DAYS_IN_WEEK = 7;
var TYPE$1 = 'week';
var endViewDateBaseComputed$1 = function (_a) {
    var viewCellsData = _a.viewCellsData;
    return endViewDate(viewCellsData);
};
var startViewDateBaseComputed$1 = function (_a) {
    var viewCellsData = _a.viewCellsData;
    return startViewDate(viewCellsData);
};
var viewCellsDataBaseComputed$1 = function (cellDuration, startDayHour, endDayHour) { return function (_a) {
    var firstDayOfWeek = _a.firstDayOfWeek, intervalCount = _a.intervalCount, excludedDays = _a.excludedDays, currentDate = _a.currentDate;
    return viewCellsData(currentDate, firstDayOfWeek, intervalCount * DAYS_IN_WEEK, excludedDays, startDayHour, endDayHour, cellDuration, Date.now());
}; };
var CellPlaceholder$1 = function (params) { return createElement(TemplatePlaceholder, { name: "cell", params: params }); };
var AppointmentPlaceholder$1 = function (params) { return createElement(TemplatePlaceholder, { name: "appointment", params: params }); };
var TimeTablePlaceholder$1 = function () { return createElement(TemplatePlaceholder, { name: "timeTable" }); };
var DayScalePlaceholder$1 = function () { return createElement(TemplatePlaceholder, { name: "dayScale" }); };
var DayScaleEmptyCellPlaceholder$1 = function () { return createElement(TemplatePlaceholder, { name: "dayScaleEmptyCell" }); };
var TimeScalePlaceholder$1 = function () { return createElement(TemplatePlaceholder, { name: "timeScale" }); };
var WeekViewBase = /*#__PURE__*/ (function (_super) {
    __extends(WeekViewBase, _super);
    function WeekViewBase() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.state = {
            rects: [],
            scrollingStrategy: {
                topBoundary: 0,
                bottomBoundary: 0,
                changeVerticalScroll: function () { return undefined; },
            },
            timeTableElementsMeta: {},
        };
        _this.scrollingStrategyComputed = memoize(function (viewName, scrollingStrategy) { return function (getters) { return computed(getters, viewName, function () { return scrollingStrategy; }, getters.scrollingStrategy); }; });
        _this.timeTableElementsMetaComputed = memoize(function (viewName, timeTableElementsMeta) { return function (getters) {
            return computed(getters, viewName, function () { return timeTableElementsMeta; }, getters.timeTableElementsMeta);
        }; });
        _this.excludedDaysComputed = memoize(function (viewName, excludedDays) { return function (getters) { return computed(getters, viewName, function () { return excludedDays; }, getters.excludedDays); }; });
        _this.firstDayOfWeekComputed = memoize(function (viewName, firstDayOfWeek) { return function (getters) { return computed(getters, viewName, function () { return firstDayOfWeek; }, getters.firstDayOfWeek); }; });
        _this.intervalCountComputed = memoize(function (viewName, intervalCount) { return function (getters) { return computed(getters, viewName, function () { return intervalCount; }, getters.intervalCount); }; });
        _this.viewCellsDataComputed = memoize(function (viewName, cellDuration, startDayHour, endDayHour) {
            return function (getters) { return computed(getters, viewName, viewCellsDataBaseComputed$1(cellDuration, startDayHour, endDayHour), getters.viewCellsData); };
        });
        _this.availableViewsComputed = memoize(function (viewName, viewDisplayName) { return function (_a) {
            var availableViews$1 = _a.availableViews;
            return availableViews(availableViews$1, viewName, viewDisplayName);
        }; });
        _this.currentViewComputed = memoize(function (viewName, viewDisplayName) { return function (_a) {
            var currentView = _a.currentView;
            return (currentView && currentView.name !== viewName
                ? currentView
                : { name: viewName, type: TYPE$1, displayName: viewDisplayName });
        }; });
        _this.endViewDateComputed = function (getters) {
            var viewName = _this.props.name;
            return computed(getters, viewName, endViewDateBaseComputed$1, getters.endViewDate);
        };
        _this.startViewDateComputed = function (getters) {
            var viewName = _this.props.name;
            return computed(getters, viewName, startViewDateBaseComputed$1, getters.startViewDate);
        };
        _this.updateRects = memoize(function (appointments, startViewDate, endViewDate, excludedDays, viewCellsData, cellDuration) { return function (cellElementsMeta) {
            var rects = verticalTimeTableRects(appointments, startViewDate, endViewDate, excludedDays, viewCellsData, cellDuration, cellElementsMeta);
            _this.setState({ rects: rects, timeTableElementsMeta: cellElementsMeta });
        }; });
        _this.setScrollingStrategy = function (scrollingStrategy) {
            _this.setState({ scrollingStrategy: scrollingStrategy });
        };
        return _this;
    }
    WeekViewBase.prototype.render = function () {
        var _this = this;
        var _a = this.props, Layout = _a.layoutComponent, DayScaleEmptyCell = _a.dayScaleEmptyCellComponent, TimeScale = _a.timeScaleLayoutComponent, TimeScaleRow = _a.timeScaleRowComponent, TimeScaleCell = _a.timeScaleCellComponent, DayScale = _a.dayScaleLayoutComponent, DayScaleCell = _a.dayScaleCellComponent, DayScaleRow = _a.dayScaleRowComponent, TimeTableLayout = _a.timeTableLayoutComponent, timeTableRowComponent = _a.timeTableRowComponent, TimeTableCell = _a.timeTableCellComponent, cellDuration = _a.cellDuration, excludedDays = _a.excludedDays, viewName = _a.name, intervalCount = _a.intervalCount, firstDayOfWeek = _a.firstDayOfWeek, startDayHour = _a.startDayHour, endDayHour = _a.endDayHour, AppointmentLayer = _a.appointmentLayerComponent, displayName = _a.displayName;
        var _b = this.state, rects = _b.rects, timeTableElementsMeta = _b.timeTableElementsMeta, scrollingStrategy = _b.scrollingStrategy;
        var viewDisplayName = displayName || viewName;
        return (createElement(Plugin, { name: "WeekView" },
            createElement(Getter, { name: "availableViews", computed: this.availableViewsComputed(viewName, viewDisplayName) }),
            createElement(Getter, { name: "currentView", computed: this.currentViewComputed(viewName, viewDisplayName) }),
            createElement(Getter, { name: "intervalCount", computed: this.intervalCountComputed(viewName, intervalCount) }),
            createElement(Getter, { name: "firstDayOfWeek", computed: this.firstDayOfWeekComputed(viewName, firstDayOfWeek) }),
            createElement(Getter, { name: "excludedDays", computed: this.excludedDaysComputed(viewName, excludedDays) }),
            createElement(Getter, { name: "viewCellsData", computed: this.viewCellsDataComputed(viewName, cellDuration, startDayHour, endDayHour) }),
            createElement(Getter, { name: "startViewDate", computed: this.startViewDateComputed }),
            createElement(Getter, { name: "endViewDate", computed: this.endViewDateComputed }),
            createElement(Getter, { name: "timeTableElementsMeta", computed: this.timeTableElementsMetaComputed(viewName, timeTableElementsMeta) }),
            createElement(Getter, { name: "scrollingStrategy", computed: this.scrollingStrategyComputed(viewName, scrollingStrategy) }),
            createElement(Template, { name: "body" },
                createElement(TemplateConnector, null, function (_a) {
                    var currentView = _a.currentView;
                    if (currentView.name !== viewName)
                        return createElement(TemplatePlaceholder, null);
                    return (createElement(Layout, { dayScaleComponent: DayScalePlaceholder$1, dayScaleEmptyCellComponent: DayScaleEmptyCellPlaceholder$1, timeTableComponent: TimeTablePlaceholder$1, timeScaleComponent: TimeScalePlaceholder$1, setScrollingStrategy: _this.setScrollingStrategy }));
                })),
            createElement(Template, { name: "dayScale" },
                createElement(TemplateConnector, null, function (_a) {
                    var currentView = _a.currentView, viewCellsData = _a.viewCellsData, formatDate = _a.formatDate;
                    if (currentView.name !== viewName)
                        return createElement(TemplatePlaceholder, null);
                    return (createElement(DayScale, { cellComponent: DayScaleCell, rowComponent: DayScaleRow, cellsData: viewCellsData, formatDate: formatDate }));
                })),
            createElement(Template, { name: "dayScaleEmptyCell" },
                createElement(TemplateConnector, null, function (_a) {
                    var currentView = _a.currentView;
                    if (currentView.name !== viewName)
                        return createElement(TemplatePlaceholder, null);
                    return (createElement(DayScaleEmptyCell, null));
                })),
            createElement(Template, { name: "timeScale" },
                createElement(TemplateConnector, null, function (_a) {
                    var currentView = _a.currentView, viewCellsData = _a.viewCellsData, formatDate = _a.formatDate;
                    if (currentView.name !== viewName)
                        return createElement(TemplatePlaceholder, null);
                    return (createElement(TimeScale, { rowComponent: TimeScaleRow, cellComponent: TimeScaleCell, cellsData: viewCellsData, formatDate: formatDate }));
                })),
            createElement(Template, { name: "timeTable" },
                createElement(TemplateConnector, null, function (_a) {
                    var formatDate = _a.formatDate, currentView = _a.currentView, viewCellsData = _a.viewCellsData, appointments = _a.appointments, startViewDate = _a.startViewDate, endViewDate = _a.endViewDate;
                    if (currentView.name !== viewName)
                        return createElement(TemplatePlaceholder, null);
                    var setRects = _this.updateRects(appointments, startViewDate, endViewDate, excludedDays, viewCellsData, cellDuration);
                    return (createElement(Fragment, null,
                        createElement(TimeTableLayout, { cellsData: viewCellsData, rowComponent: timeTableRowComponent, cellComponent: CellPlaceholder$1, formatDate: formatDate, setCellElementsMeta: setRects }),
                        createElement(AppointmentLayer, null, rects.map(function (_a, index) {
                            var dataItem = _a.dataItem, type = _a.type, fromPrev = _a.fromPrev, toNext = _a.toNext, geometry = __rest(_a, ["dataItem", "type", "fromPrev", "toNext"]);
                            return (createElement(AppointmentPlaceholder$1, { key: index.toString(), type: type, data: dataItem, fromPrev: fromPrev, toNext: toNext, style: getAppointmentStyle(geometry) }));
                        }))));
                })),
            createElement(Template, { name: "cell" }, function (params) { return (createElement(TemplateConnector, null, function (_a) {
                var currentView = _a.currentView;
                if (currentView.name !== viewName)
                    return createElement(TemplatePlaceholder, { params: params });
                return (createElement(TimeTableCell, __assign({}, params)));
            })); })));
    };
    WeekViewBase.defaultProps = {
        startDayHour: 0,
        endDayHour: 24,
        cellDuration: 30,
        intervalCount: 1,
        firstDayOfWeek: 0,
        excludedDays: [],
        name: 'Week',
    };
    WeekViewBase.components = {
        layoutComponent: 'Layout',
        layoutContainerComponent: 'LayoutContainer',
        appointmentLayerComponent: 'AppointmentLayer',
        dayScaleEmptyCellComponent: 'DayScaleEmptyCell',
        timeScaleLayoutComponent: 'TimeScaleLayout',
        timeScaleCellComponent: 'TimeScaleCell',
        timeScaleRowComponent: 'TimeScaleRow',
        dayScaleLayoutComponent: 'DayScaleLayout',
        dayScaleCellComponent: 'DayScaleCell',
        dayScaleRowComponent: 'DayScaleRow',
        timeTableContainerComponent: 'TimeTableContainer',
        timeTableLayoutComponent: 'TimeTableLayout',
        timeTableCellComponent: 'TimeTableCell',
        timeTableRowComponent: 'TimeTableRow',
    };
    return WeekViewBase;
}(PureComponent));
// tslint:disable: max-line-length
/***
 * A plugin that renders the Scheduler's week view. This plugin arranges appointments from top to bottom.
 * If their time intervals overlap, their width is decreased and they are placed next to each other.
 * */
var WeekView = WeekViewBase;

var TYPE$2 = 'month';
var viewCellsDataBaseComputed$2 = function (firstDayOfWeek, intervalCount) { return function (_a) {
    var currentDate = _a.currentDate;
    return monthCellsData(currentDate, firstDayOfWeek, intervalCount, Date.now());
}; };
var startViewDateBaseComputed$2 = function (_a) {
    var viewCellsData = _a.viewCellsData;
    return startViewDate(viewCellsData);
};
var endViewDateBaseComputed$2 = function (_a) {
    var viewCellsData = _a.viewCellsData;
    return endViewDate(viewCellsData);
};
var DayScalePlaceholder$2 = function () { return createElement(TemplatePlaceholder, { name: "dayScale" }); };
var TimeTablePlaceholder$2 = function () { return createElement(TemplatePlaceholder, { name: "timeTable" }); };
var CellPlaceholder$2 = function (params) { return createElement(TemplatePlaceholder, { name: "cell", params: params }); };
var AppointmentPlaceholder$2 = function (params) { return createElement(TemplatePlaceholder, { name: "appointment", params: params }); };
var MonthViewBase = /*#__PURE__*/ (function (_super) {
    __extends(MonthViewBase, _super);
    function MonthViewBase() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.state = {
            rects: [],
            timeTableElementsMeta: {},
            scrollingStrategy: {
                topBoundary: 0,
                bottomBoundary: 0,
                changeVerticalScroll: function () { return undefined; },
            },
        };
        _this.scrollingStrategyComputed = memoize(function (viewName, scrollingStrategy) { return function (getters) {
            return computed(getters, viewName, function () { return scrollingStrategy; }, getters.scrollingStrategy);
        }; });
        _this.timeTableElementsMetaComputed = memoize(function (viewName, timeTableElementsMeta) { return function (getters) {
            return computed(getters, viewName, function () { return timeTableElementsMeta; }, getters.timeTableElementsMeta);
        }; });
        _this.firstDayOfWeekComputed = memoize(function (viewName, firstDayOfWeek) { return function (getters) {
            return computed(getters, viewName, function () { return firstDayOfWeek; }, getters.firstDayOfWeek);
        }; });
        _this.intervalCountComputed = memoize(function (viewName, intervalCount) { return function (getters) {
            return computed(getters, viewName, function () { return intervalCount; }, getters.intervalCount);
        }; });
        _this.availableViewsComputed = memoize(function (viewName, viewDisplayName) { return function (_a) {
            var availableViews$1 = _a.availableViews;
            return availableViews(availableViews$1, viewName, viewDisplayName);
        }; });
        _this.currentViewComputed = memoize(function (viewName, viewDisplayName) { return function (_a) {
            var currentView = _a.currentView;
            return (currentView && currentView.name !== viewName
                ? currentView
                : { name: viewName, type: TYPE$2, displayName: viewDisplayName });
        }; });
        _this.endViewDateComputed = function (getters) {
            var viewName = _this.props.name;
            return computed(getters, viewName, endViewDateBaseComputed$2, getters.endViewDate);
        };
        _this.startViewDateComputed = function (getters) {
            var viewName = _this.props.name;
            return computed(getters, viewName, startViewDateBaseComputed$2, getters.startViewDate);
        };
        _this.viewCellsDataComputed = function (getters) {
            var viewName = _this.props.name;
            return computed(getters, viewName, viewCellsDataBaseComputed$2(getters.firstDayOfWeek, getters.intervalCount), getters.viewCellsData);
        };
        _this.updateRects = memoize(function (appointments, startViewDate, endViewDate, viewCellsData) { return function (cellElementsMeta) {
            var rects = horizontalTimeTableRects(appointments, startViewDate, endViewDate, viewCellsData, cellElementsMeta);
            _this.setState({ rects: rects, timeTableElementsMeta: cellElementsMeta });
        }; });
        _this.setScrollingStrategy = function (scrollingStrategy) {
            _this.setState({ scrollingStrategy: scrollingStrategy });
        };
        return _this;
    }
    MonthViewBase.prototype.render = function () {
        var _this = this;
        var _a = this.props, Layout = _a.layoutComponent, DayScale = _a.dayScaleLayoutComponent, DayScaleCell = _a.dayScaleCellComponent, DayScaleRow = _a.dayScaleRowComponent, TimeTableLayout = _a.timeTableLayoutComponent, timeTableRowComponent = _a.timeTableRowComponent, TimeTableCell = _a.timeTableCellComponent, AppointmentLayer = _a.appointmentLayerComponent, viewName = _a.name, firstDayOfWeek = _a.firstDayOfWeek, intervalCount = _a.intervalCount, displayName = _a.displayName;
        var _b = this.state, rects = _b.rects, timeTableElementsMeta = _b.timeTableElementsMeta, scrollingStrategy = _b.scrollingStrategy;
        var viewDisplayName = displayName || viewName;
        return (createElement(Plugin, { name: "MonthView" },
            createElement(Getter, { name: "availableViews", computed: this.availableViewsComputed(viewName, viewDisplayName) }),
            createElement(Getter, { name: "currentView", computed: this.currentViewComputed(viewName, viewDisplayName) }),
            createElement(Getter, { name: "firstDayOfWeek", computed: this.firstDayOfWeekComputed(viewName, firstDayOfWeek) }),
            createElement(Getter, { name: "intervalCount", computed: this.intervalCountComputed(viewName, intervalCount) }),
            createElement(Getter, { name: "viewCellsData", computed: this.viewCellsDataComputed }),
            createElement(Getter, { name: "startViewDate", computed: this.startViewDateComputed }),
            createElement(Getter, { name: "endViewDate", computed: this.endViewDateComputed }),
            createElement(Getter, { name: "timeTableElementsMeta", computed: this.timeTableElementsMetaComputed(viewName, timeTableElementsMeta) }),
            createElement(Getter, { name: "scrollingStrategy", computed: this.scrollingStrategyComputed(viewName, scrollingStrategy) }),
            createElement(Template, { name: "body" },
                createElement(TemplateConnector, null, function (_a) {
                    var currentView = _a.currentView;
                    if (currentView.name !== viewName)
                        return createElement(TemplatePlaceholder, null);
                    return (createElement(Layout, { dayScaleComponent: DayScalePlaceholder$2, timeTableComponent: TimeTablePlaceholder$2, setScrollingStrategy: _this.setScrollingStrategy }));
                })),
            createElement(Template, { name: "dayScale" },
                createElement(TemplateConnector, null, function (_a) {
                    var currentView = _a.currentView, viewCellsData = _a.viewCellsData, formatDate = _a.formatDate;
                    if (currentView.name !== viewName)
                        return createElement(TemplatePlaceholder, null);
                    return (createElement(DayScale, { cellComponent: DayScaleCell, rowComponent: DayScaleRow, cellsData: viewCellsData, formatDate: formatDate }));
                })),
            createElement(Template, { name: "timeTable" },
                createElement(TemplateConnector, null, function (_a) {
                    var appointments = _a.appointments, startViewDate = _a.startViewDate, endViewDate = _a.endViewDate, currentView = _a.currentView, viewCellsData = _a.viewCellsData, formatDate = _a.formatDate;
                    if (currentView.name !== viewName)
                        return createElement(TemplatePlaceholder, null);
                    var setRects = _this.updateRects(appointments, startViewDate, endViewDate, viewCellsData);
                    return (createElement(Fragment, null,
                        createElement(TimeTableLayout, { cellsData: viewCellsData, rowComponent: timeTableRowComponent, cellComponent: CellPlaceholder$2, formatDate: formatDate, setCellElementsMeta: setRects }),
                        createElement(AppointmentLayer, null, rects.map(function (_a, index) {
                            var dataItem = _a.dataItem, type = _a.type, fromPrev = _a.fromPrev, toNext = _a.toNext, geometry = __rest(_a, ["dataItem", "type", "fromPrev", "toNext"]);
                            return (createElement(AppointmentPlaceholder$2, { key: index.toString(), type: type, data: dataItem, fromPrev: fromPrev, toNext: toNext, style: getAppointmentStyle(geometry) }));
                        }))));
                })),
            createElement(Template, { name: "cell" }, function (params) { return (createElement(TemplateConnector, null, function (_a) {
                var currentView = _a.currentView;
                if (currentView.name !== viewName)
                    return createElement(TemplatePlaceholder, { params: params });
                return (createElement(TimeTableCell, __assign({}, params)));
            })); })));
    };
    MonthViewBase.defaultProps = {
        intervalCount: 1,
        firstDayOfWeek: 0,
        name: 'Month',
    };
    MonthViewBase.components = {
        layoutComponent: 'Layout',
        appointmentLayerComponent: 'AppointmentLayer',
        dayScaleLayoutComponent: 'DayScaleLayout',
        dayScaleCellComponent: 'DayScaleCell',
        dayScaleRowComponent: 'DayScaleRow',
        timeTableContainerComponent: 'TimeTableContainer',
        timeTableLayoutComponent: 'TimeTableLayout',
        timeTableCellComponent: 'TimeTableCell',
        timeTableRowComponent: 'TimeTableRow',
    };
    return MonthViewBase;
}(PureComponent));
// tslint:disable: max-line-length
/***
 * A plugin that renders Scheduler data for a month. This plugin arranges appointments from left to right.
 * An appointment's size depends on its duration in days.
 * However, it occupies the entire day cell if an appointment lasts only for several hours or minutes.
 * The time scale and all-day panel are not available in this view.
 * */
var MonthView = MonthViewBase;

var ToolbarBase = /*#__PURE__*/ (function (_super) {
    __extends(ToolbarBase, _super);
    function ToolbarBase() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    ToolbarBase.prototype.render = function () {
        var _a = this.props, Root = _a.rootComponent, FlexibleSpaceComponent = _a.flexibleSpaceComponent;
        return (createElement(Plugin, { name: "Toolbar" },
            createElement(Template, { name: "header" },
                createElement(Root, null,
                    createElement(TemplatePlaceholder, { name: "toolbarContent" })),
                createElement(TemplatePlaceholder, null)),
            createElement(Template, { name: "toolbarContent" },
                createElement(FlexibleSpaceComponent, null))));
    };
    ToolbarBase.components = {
        rootComponent: 'Root',
        flexibleSpaceComponent: 'FlexibleSpace',
    };
    return ToolbarBase;
}(PureComponent));
/** A plugin that renders the Scheduler's toolbar. */
var Toolbar = ToolbarBase;

var pluginDependencies = [
    { name: 'Toolbar' },
    { name: 'ViewState' },
];
var navigate = function (action, currentView, intervalCount) { return function (direction, nextDate) { return action({
    direction: direction,
    nextDate: nextDate,
    amount: intervalCount,
    step: currentView.type,
}); }; };
var DateNavigatorBase = /*#__PURE__*/ (function (_super) {
    __extends(DateNavigatorBase, _super);
    function DateNavigatorBase() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.state = {
            visible: false,
        };
        _this.setRootRef = function (target) {
            _this.target = target;
        };
        _this.handleVisibilityToggle = function () {
            _this.setState(function (prevState) { return ({ visible: !prevState.visible }); });
        };
        _this.handleHide = function () {
            _this.setState({ visible: false });
        };
        _this.navigateAction = memoize(function (changeCurrentDate, currentView, intervalCount, navigateAction) {
            return navigateAction(changeCurrentDate, currentView, intervalCount);
        });
        return _this;
    }
    DateNavigatorBase.prototype.render = function () {
        var _this = this;
        var _a = this.props, Root = _a.rootComponent, Overlay = _a.overlayComponent, OpenButton = _a.openButtonComponent, NavigationButton = _a.navigationButtonComponent, Calendar = _a.calendarComponent, CalendarRow = _a.calendarRowComponent, CalendarCell = _a.calendarCellComponent, CalendarHeaderRow = _a.calendarHeaderRowComponent, CalendarHeaderCell = _a.calendarHeaderCellComponent, CalendarText = _a.calendarTextComponent, CalendarNavigationButton = _a.calendarNavigationButtonComponent, CalendarNavigator = _a.calendarNavigatorComponent;
        var visible = this.state.visible;
        return (createElement(Plugin, { name: "DateNavigator", dependencies: pluginDependencies },
            createElement(Template, { name: "toolbarContent" },
                createElement(TemplateConnector, null, function (_a, _b) {
                    var currentDate = _a.currentDate, startViewDate = _a.startViewDate, endViewDate = _a.endViewDate, firstDayOfWeek = _a.firstDayOfWeek, currentView = _a.currentView, intervalCount = _a.intervalCount, formatDate = _a.formatDate;
                    var changeCurrentDate = _b.changeCurrentDate;
                    var navigateAction = _this.navigateAction(changeCurrentDate, currentView, intervalCount, navigate);
                    var calendarDateChanged = function (nextDate) {
                        navigateAction(undefined, nextDate);
                        _this.handleHide();
                    };
                    var navigatorText = viewBoundText(startViewDate, endViewDate, currentView, currentDate, intervalCount, formatDate);
                    return (createElement(Fragment, null,
                        createElement(Root, { navigationButtonComponent: NavigationButton, openButtonComponent: OpenButton, navigatorText: navigatorText, rootRef: _this.setRootRef, onVisibilityToggle: _this.handleVisibilityToggle, onNavigate: navigateAction }),
                        createElement(Overlay, { visible: visible, target: _this.target, onHide: _this.handleHide },
                            createElement(Calendar, { selectedDate: currentDate, firstDayOfWeek: firstDayOfWeek, getCells: monthCellsData, textComponent: CalendarText, navigationButtonComponent: CalendarNavigationButton, rowComponent: CalendarRow, cellComponent: CalendarCell, headerRowComponent: CalendarHeaderRow, headerCellComponent: CalendarHeaderCell, navigatorComponent: CalendarNavigator, onSelectedDateChange: calendarDateChanged, formatDate: formatDate }))));
                }),
                createElement(TemplatePlaceholder, null))));
    };
    DateNavigatorBase.components = {
        rootComponent: 'Root',
        overlayComponent: 'Overlay',
        openButtonComponent: 'OpenButton',
        navigationButtonComponent: 'NavigationButton',
        calendarComponent: 'Calendar',
        calendarRowComponent: 'CalendarRow',
        calendarCellComponent: 'CalendarCell',
        calendarHeaderRowComponent: 'CalendarHeaderRow',
        calendarHeaderCellComponent: 'CalendarHeaderCell',
        calendarTextComponent: 'CalendarText',
        calendarNavigatorComponent: 'CalendarNavigator',
        calendarNavigationButtonComponent: 'CalendarNavigationButton',
    };
    return DateNavigatorBase;
}(PureComponent));
/** A plugin that renders the Scheduler’s date navigator. */
var DateNavigator = DateNavigatorBase;

var pluginDependencies$1 = [
    { name: 'Toolbar' },
    { name: 'ViewState' },
];
var ViewSwitcherBase = /*#__PURE__*/ (function (_super) {
    __extends(ViewSwitcherBase, _super);
    function ViewSwitcherBase() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    ViewSwitcherBase.prototype.render = function () {
        var Switcher = this.props.switcherComponent;
        return (createElement(Plugin, { name: "ViewSwitcher", dependencies: pluginDependencies$1 },
            createElement(Template, { name: "toolbarContent" },
                createElement(TemplatePlaceholder, null),
                createElement(TemplateConnector, null, function (_a, _b) {
                    var currentView = _a.currentView, availableViews = _a.availableViews;
                    var setCurrentViewName = _b.setCurrentViewName;
                    return (createElement(Switcher, { currentView: currentView, availableViews: availableViews, onChange: setCurrentViewName }));
                }))));
    };
    ViewSwitcherBase.components = {
        switcherComponent: 'Switcher',
    };
    return ViewSwitcherBase;
}(PureComponent));
/** A plugin that renders the Scheduler's view switcher. */
var ViewSwitcher = ViewSwitcherBase;

var pluginDependencies$2 = [
    { name: 'DayView', optional: true },
    { name: 'WeekView', optional: true },
    { name: 'MonthView', optional: true },
];
var AppointmentsBase = /*#__PURE__*/ (function (_super) {
    __extends(AppointmentsBase, _super);
    function AppointmentsBase() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    AppointmentsBase.prototype.render = function () {
        var _a = this.props, SplitIndicator = _a.splitIndicatorComponent, Appointment = _a.appointmentComponent, AppointmentContent = _a.appointmentContentComponent, Container = _a.containerComponent, recurringIconComponent = _a.recurringIconComponent;
        return (createElement(Plugin, { name: "Appointments", dependencies: pluginDependencies$2 },
            createElement(Template, { name: "appointment" }, function (_a) {
                var style = _a.style, params = __rest(_a, ["style"]);
                return (createElement(TemplateConnector, null, function (_a) {
                    var formatDate = _a.formatDate;
                    return (createElement(Container, { style: style },
                        createElement(TemplatePlaceholder, { name: "appointmentTop", params: { data: params.data, type: params.type, slice: params.fromPrev } }),
                        createElement(TemplatePlaceholder, { name: "appointmentContent", params: __assign(__assign({}, params), { formatDate: formatDate }) }),
                        createElement(TemplatePlaceholder, { name: "appointmentBottom", params: { data: params.data, type: params.type, slice: params.toNext } })));
                }));
            }),
            createElement(Template, { name: "appointmentContent" }, function (_a) {
                var onClick = _a.onClick, onDoubleClick = _a.onDoubleClick, formatDate = _a.formatDate, data = _a.data, type = _a.type, fromPrev = _a.fromPrev, toNext = _a.toNext, restParams = __rest(_a, ["onClick", "onDoubleClick", "formatDate", "data", "type", "fromPrev", "toNext"]);
                return (createElement(Appointment, __assign({ data: data }, createClickHandlers(onClick, onDoubleClick), restParams),
                    fromPrev && createElement(SplitIndicator, { position: POSITION_START, appointmentType: type }),
                    createElement(AppointmentContent, { data: data, type: type, recurringIconComponent: recurringIconComponent, formatDate: formatDate }),
                    toNext && createElement(SplitIndicator, { position: POSITION_END, appointmentType: type })));
            })));
    };
    AppointmentsBase.components = {
        splitIndicatorComponent: 'SplitIndicator',
        containerComponent: 'Container',
        appointmentComponent: 'Appointment',
        appointmentContentComponent: 'AppointmentContent',
        recurringIconComponent: 'RecurringIcon',
    };
    return AppointmentsBase;
}(PureComponent));
/** A plugin that renders appointments. */
var Appointments = AppointmentsBase;

var pluginDependencies$3 = [
    { name: 'DayView', optional: true },
    { name: 'WeekView', optional: true },
];
var defaultMessages = {
    allDay: 'All Day',
};
var MONTH = 'Month';
var AppointmentPlaceholder$3 = function (params) { return createElement(TemplatePlaceholder, { name: "appointment", params: params }); };
var AllDayPanelPlaceholder = function (params) { return createElement(TemplatePlaceholder, { name: "allDayPanel", params: params }); };
var CellPlaceholder$3 = function (params) { return createElement(TemplatePlaceholder, { name: "allDayPanelCell", params: params }); };
var AllDayPanelBase = /*#__PURE__*/ (function (_super) {
    __extends(AllDayPanelBase, _super);
    function AllDayPanelBase() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.state = {
            rects: [],
            elementsMeta: {},
        };
        _this.allDayCellsData = memoize(function (viewCellsData) { return allDayCells(viewCellsData); });
        _this.updateRects = memoize(function (appointments, startViewDate, excludedDays, endViewDate, viewCellsData) { return function (cellElementsMeta) {
            var allDayLeftBound = moment(startViewDate).hours(0).minutes(0).toDate();
            var allDayRightBound = moment(endViewDate).hours(23).minutes(59).toDate();
            var rects = allDayRects(appointments, allDayLeftBound, allDayRightBound, excludedDays, viewCellsData, cellElementsMeta);
            _this.setState({ rects: rects, elementsMeta: cellElementsMeta });
        }; });
        _this.getMessageFormatter = memoize(function (messages, allDayPanelDefaultMessages) {
            return getMessagesFormatter(__assign(__assign({}, allDayPanelDefaultMessages), messages));
        });
        return _this;
    }
    AllDayPanelBase.prototype.render = function () {
        var _this = this;
        var _a = this.props, AppointmentLayer = _a.appointmentLayerComponent, Layout = _a.layoutComponent, Cell = _a.cellComponent, rowComponent = _a.rowComponent, TitleCell = _a.titleCellComponent, Container = _a.containerComponent, messages = _a.messages;
        var _b = this.state, rects = _b.rects, elementsMeta = _b.elementsMeta;
        var getMessage = this.getMessageFormatter(messages, defaultMessages);
        return (createElement(Plugin, { name: "AllDayPanel", dependencies: pluginDependencies$3 },
            createElement(Getter, { name: "allDayElementsMeta", value: elementsMeta }),
            createElement(Template, { name: "dayScaleEmptyCell" },
                createElement(TemplateConnector, null, function (_a) {
                    var currentView = _a.currentView;
                    if (currentView === MONTH)
                        return null;
                    return (createElement(TitleCell, { getMessage: getMessage }));
                })),
            createElement(Template, { name: "dayScale" },
                createElement(TemplatePlaceholder, null),
                createElement(TemplateConnector, null, function (_a) {
                    var currentView = _a.currentView;
                    if (currentView === MONTH)
                        return null;
                    return (createElement(Container, null,
                        createElement(AllDayPanelPlaceholder, null)));
                })),
            createElement(Template, { name: "allDayPanel" },
                createElement(TemplatePlaceholder, null),
                createElement(TemplateConnector, null, function (_a) {
                    var currentView = _a.currentView, appointments = _a.appointments, startViewDate = _a.startViewDate, formatDate = _a.formatDate, endViewDate = _a.endViewDate, excludedDays = _a.excludedDays, viewCellsData = _a.viewCellsData;
                    if (currentView.name === MONTH)
                        return null;
                    var setRects = _this.updateRects(appointments, startViewDate, excludedDays, endViewDate, viewCellsData);
                    return (createElement(Fragment, null,
                        createElement(Layout, { cellComponent: CellPlaceholder$3, rowComponent: rowComponent, cellsData: _this.allDayCellsData(viewCellsData), setCellElementsMeta: setRects, formatDate: formatDate }),
                        createElement(AppointmentLayer, null, rects.map(function (_a, index) {
                            var dataItem = _a.dataItem, type = _a.type, fromPrev = _a.fromPrev, toNext = _a.toNext, geometry = __rest(_a, ["dataItem", "type", "fromPrev", "toNext"]);
                            return (createElement(AppointmentPlaceholder$3, { style: getAppointmentStyle(geometry), type: type, key: index.toString(), data: dataItem, fromPrev: fromPrev, toNext: toNext }));
                        }))));
                })),
            createElement(Template, { name: "allDayPanelCell" }, function (params) { return createElement(Cell, __assign({}, params)); })));
    };
    AllDayPanelBase.defaultProps = {
        messages: {},
    };
    AllDayPanelBase.components = {
        appointmentLayerComponent: 'AppointmentLayer',
        layoutComponent: 'Layout',
        layoutContainerComponent: 'LayoutContainer',
        cellComponent: 'Cell',
        rowComponent: 'Row',
        titleCellComponent: 'TitleCell',
        containerComponent: 'Container',
    };
    return AllDayPanelBase;
}(PureComponent));
/** A plugin that renders the All Day Panel. */
var AllDayPanel = AllDayPanelBase;

var ViewStateBase = /*#__PURE__*/ (function (_super) {
    __extends(ViewStateBase, _super);
    function ViewStateBase(props) {
        var _this = _super.call(this, props) || this;
        _this.getCurrentViewComputed = memoize(function (currentViewName) { return function () { return (currentViewName
            ? { name: currentViewName }
            : undefined); }; });
        _this.state = {
            currentDate: props.currentDate || props.defaultCurrentDate,
            currentViewName: props.currentViewName || props.defaultCurrentViewName,
        };
        var stateHelper = createStateHelper(_this, {
            currentDate: function () {
                var onCurrentDateChange = _this.props.onCurrentDateChange;
                return onCurrentDateChange;
            },
            currentViewName: function () {
                var onCurrentViewNameChange = _this.props.onCurrentViewNameChange;
                return onCurrentViewNameChange;
            },
        });
        _this.changeCurrentDate = stateHelper.applyFieldReducer
            .bind(stateHelper, 'currentDate', changeCurrentDate);
        _this.setCurrentViewName = stateHelper.applyFieldReducer
            .bind(stateHelper, 'currentViewName', setCurrentViewName);
        return _this;
    }
    ViewStateBase.getDerivedStateFromProps = function (nextProps, prevState) {
        var _a = nextProps.currentDate, currentDate = _a === void 0 ? prevState.currentDate : _a, _b = nextProps.currentViewName, currentViewName = _b === void 0 ? prevState.currentViewName : _b;
        return {
            currentDate: currentDate,
            currentViewName: currentViewName,
        };
    };
    ViewStateBase.prototype.render = function () {
        var _a = this.state, currentDate = _a.currentDate, stateCurrentViewName = _a.currentViewName;
        return (createElement(Plugin, { name: "ViewState" },
            createElement(Getter, { name: "currentDate", value: currentDate }),
            createElement(Getter, { name: "currentView", computed: this.getCurrentViewComputed(stateCurrentViewName) }),
            createElement(Action, { name: "changeCurrentDate", action: this.changeCurrentDate }),
            createElement(Action, { name: "setCurrentViewName", action: this.setCurrentViewName })));
    };
    ViewStateBase.defaultProps = {
        defaultCurrentDate: new Date(),
    };
    return ViewStateBase;
}(PureComponent));
/** A plugin that manages the view state. It specifies the current date and the displayed view. */
var ViewState = ViewStateBase;

var EditingStateBase = /*#__PURE__*/ (function (_super) {
    __extends(EditingStateBase, _super);
    function EditingStateBase(props) {
        var _this = _super.call(this, props) || this;
        _this.state = {
            editingAppointment: props.editingAppointment || props.defaultEditingAppointment,
            addedAppointment: props.addedAppointment || props.defaultAddedAppointment,
            appointmentChanges: props.appointmentChanges || props.defaultAppointmentChanges,
        };
        var stateHelper = createStateHelper(_this, {
            editingAppointment: function () {
                var onEditingAppointmentChange = _this.props.onEditingAppointmentChange;
                return onEditingAppointmentChange;
            },
            addedAppointment: function () {
                var onAddedAppointmentChange = _this.props.onAddedAppointmentChange;
                return onAddedAppointmentChange;
            },
            appointmentChanges: function () {
                var onAppointmentChangesChange = _this.props.onAppointmentChangesChange;
                return onAppointmentChangesChange;
            },
        });
        _this.startEditAppointment = stateHelper.applyFieldReducer
            .bind(stateHelper, 'editingAppointment', startEditAppointment);
        _this.stopEditAppointment = stateHelper.applyFieldReducer
            .bind(stateHelper, 'editingAppointment', stopEditAppointment);
        _this.changeAppointment = stateHelper.applyFieldReducer
            .bind(stateHelper, 'appointmentChanges', changeAppointment);
        _this.cancelChangedAppointment = stateHelper.applyFieldReducer
            .bind(stateHelper, 'appointmentChanges', cancelChanges);
        _this.commitChangedAppointment = function (type) {
            if (type === void 0) { type = RECURRENCE_EDIT_SCOPE.CURRENT; }
            var _a = _this.state, appointmentChanges = _a.appointmentChanges, editingAppointment = _a.editingAppointment;
            var _b = _this.props, onCommitChanges = _b.onCommitChanges, preCommitChanges = _b.preCommitChanges;
            if (!editingAppointment)
                return;
            var changes = !editingAppointment.rRule
                ? { changed: changedAppointmentById(appointmentChanges, editingAppointment.id) }
                : preCommitChanges(appointmentChanges, editingAppointment, type);
            onCommitChanges(changes);
            _this.cancelChangedAppointment();
            _this.stopEditAppointment();
        };
        _this.addAppointment = stateHelper.applyFieldReducer
            .bind(stateHelper, 'addedAppointment', addAppointment);
        _this.changeAddedAppointment = stateHelper.applyFieldReducer
            .bind(stateHelper, 'addedAppointment', changeAppointment);
        _this.cancelAddedAppointment = stateHelper.applyFieldReducer
            .bind(stateHelper, 'addedAppointment', cancelAddedAppointment);
        _this.commitAddedAppointment = function () {
            var onCommitChanges = _this.props.onCommitChanges;
            var stateAddedAppointment = _this.state.addedAppointment;
            onCommitChanges({
                added: stateAddedAppointment,
            });
            _this.cancelAddedAppointment();
        };
        _this.commitDeletedAppointment = function (_a) {
            var deletedAppointmentData = _a.deletedAppointmentData, _b = _a.type, type = _b === void 0 ? 'current' : _b;
            var _c = _this.props, onCommitChanges = _c.onCommitChanges, preCommitChanges = _c.preCommitChanges;
            var changes = deletedAppointmentData.rRule
                ? preCommitChanges(null, deletedAppointmentData, type)
                : { deleted: deletedAppointmentData.id };
            onCommitChanges(changes);
        };
        return _this;
    }
    EditingStateBase.getDerivedStateFromProps = function (nextProps, prevState) {
        var _a = nextProps.editingAppointment, editingAppointment = _a === void 0 ? prevState.editingAppointment : _a, _b = nextProps.appointmentChanges, appointmentChanges = _b === void 0 ? prevState.appointmentChanges : _b, _c = nextProps.addedAppointment, addedAppointment = _c === void 0 ? prevState.addedAppointment : _c;
        return {
            editingAppointment: editingAppointment,
            appointmentChanges: appointmentChanges,
            addedAppointment: addedAppointment,
        };
    };
    EditingStateBase.prototype.render = function () {
        var _a = this.state, addedAppointment = _a.addedAppointment, editingAppointment = _a.editingAppointment, appointmentChanges = _a.appointmentChanges;
        return (createElement(Plugin, { name: "EditingState" },
            createElement(Getter, { name: "editingAppointment", value: editingAppointment }),
            createElement(Action, { name: "startEditAppointment", action: this.startEditAppointment }),
            createElement(Action, { name: "stopEditAppointment", action: this.stopEditAppointment }),
            createElement(Getter, { name: "appointmentChanges", value: appointmentChanges }),
            createElement(Action, { name: "changeAppointment", action: this.changeAppointment }),
            createElement(Action, { name: "cancelChangedAppointment", action: this.cancelChangedAppointment }),
            createElement(Action, { name: "commitChangedAppointment", action: this.commitChangedAppointment }),
            createElement(Getter, { name: "addedAppointment", value: addedAppointment }),
            createElement(Action, { name: "addAppointment", action: this.addAppointment }),
            createElement(Action, { name: "changeAddedAppointment", action: this.changeAddedAppointment }),
            createElement(Action, { name: "cancelAddedAppointment", action: this.cancelAddedAppointment }),
            createElement(Action, { name: "commitAddedAppointment", action: this.commitAddedAppointment }),
            createElement(Action, { name: "commitDeletedAppointment", action: this.commitDeletedAppointment })));
    };
    EditingStateBase.defaultProps = {
        defaultEditingAppointment: undefined,
        defaultAppointmentChanges: {},
        defaultAddedAppointment: {},
        preCommitChanges: preCommitChanges,
    };
    return EditingStateBase;
}(PureComponent));
/** A plugin that manages the scheduler appointment editing state. */
var EditingState = EditingStateBase;

var pluginDependencies$4 = [
    { name: 'Appointments' },
    { name: 'EditingState', optional: true },
    { name: 'IntegratedEditing', optional: true },
    { name: 'EditRecurrenceMenu', optional: true },
];
var commandButtonIds = {
    open: OPEN_COMMAND_BUTTON,
    close: CLOSE_COMMAND_BUTTON,
    delete: DELETE_COMMAND_BUTTON,
};
var AppointmentTooltipBase = /*#__PURE__*/ (function (_super) {
    __extends(AppointmentTooltipBase, _super);
    function AppointmentTooltipBase(props) {
        var _this = _super.call(this, props) || this;
        _this.state = {
            visible: props.visible,
            appointmentMeta: props.appointmentMeta,
        };
        var stateHelper = createStateHelper(_this, {
            visible: function () {
                var onVisibilityChange = _this.props.onVisibilityChange;
                return onVisibilityChange;
            },
            appointmentMeta: function () {
                var onAppointmentMetaChange = _this.props.onAppointmentMetaChange;
                return onAppointmentMetaChange;
            },
        });
        var toggleVisibility = function () {
            var isOpen = _this.state.visible;
            return !isOpen;
        };
        _this.toggleVisibility = stateHelper.applyFieldReducer
            .bind(stateHelper, 'visible', toggleVisibility);
        _this.setAppointmentMeta = stateHelper.applyFieldReducer
            .bind(stateHelper, 'appointmentMeta', setAppointmentMeta);
        _this.onAppointmentClick = function (_a) {
            var target = _a.target, data = _a.data;
            _this.setAppointmentMeta({ target: target, data: data });
            _this.toggleVisibility();
        };
        return _this;
    }
    AppointmentTooltipBase.getDerivedStateFromProps = function (nextProps, prevState) {
        var _a = nextProps.visible, visible = _a === void 0 ? prevState.visible : _a, _b = nextProps.appointmentMeta, appointmentMeta = _b === void 0 ? prevState.appointmentMeta : _b;
        return {
            appointmentMeta: appointmentMeta,
            visible: visible,
        };
    };
    AppointmentTooltipBase.prototype.render = function () {
        var _this = this;
        var _a = this.props, showOpenButton = _a.showOpenButton, showDeleteButton = _a.showDeleteButton, showCloseButton = _a.showCloseButton, Layout = _a.layoutComponent, headerComponent = _a.headerComponent, contentComponent = _a.contentComponent, commandButtonComponent = _a.commandButtonComponent;
        var _b = this.state, visible = _b.visible, appointmentMeta = _b.appointmentMeta;
        return (createElement(Plugin, { name: "AppointmentTooltip", dependencies: pluginDependencies$4 },
            createElement(Template, { name: "timeTable" },
                createElement(TemplatePlaceholder, null),
                createElement(TemplateConnector, null, function (_a, _b) {
                    var formatDate = _a.formatDate;
                    var finishDeleteAppointment = _b.finishDeleteAppointment;
                    var onDeleteButtonClick = function () {
                        finishDeleteAppointment(appointmentMeta.data);
                        _this.toggleVisibility();
                    };
                    return (createElement(TemplatePlaceholder, { name: "tooltip", params: __assign(__assign({ commandButtonComponent: commandButtonComponent,
                            showOpenButton: showOpenButton,
                            showDeleteButton: showDeleteButton,
                            showCloseButton: showCloseButton,
                            headerComponent: headerComponent,
                            contentComponent: contentComponent,
                            appointmentMeta: appointmentMeta,
                            visible: visible, onHide: _this.toggleVisibility, commandButtonIds: commandButtonIds }, finishDeleteAppointment && {
                            onDeleteButtonClick: onDeleteButtonClick,
                        }), { formatDate: formatDate }) }));
                })),
            createElement(Template, { name: "tooltip" }, function (params) { return createElement(Layout, __assign({}, params)); }),
            createElement(Template, { name: "appointment" }, function (params) { return (createElement(TemplatePlaceholder, { params: __assign(__assign({}, params), { onClick: function (_a) {
                        var target = _a.target, data = _a.data;
                        return _this.onAppointmentClick({ target: target, data: data });
                    } }) })); })));
    };
    AppointmentTooltipBase.defaultProps = {
        showOpenButton: false,
        showDeleteButton: false,
        showCloseButton: false,
    };
    AppointmentTooltipBase.components = {
        layoutComponent: 'Layout',
        headerComponent: 'Header',
        contentComponent: 'Content',
        commandButtonComponent: 'CommandButton',
    };
    return AppointmentTooltipBase;
}(PureComponent));
// tslint:disable: max-line-length
/** The AppointmentTooltip plugin allows you to display information about an appointment in a tooltip. */
var AppointmentTooltip = AppointmentTooltipBase;

var defaultMessages$1 = {
    allDayLabel: 'All Day',
    titleLabel: 'Title',
    startDateLabel: 'Start Date',
    endDateLabel: 'End Date',
    commitCommand: 'Save',
    cancelCommand: 'Cancel',
};
var pluginDependencies$5 = [
    { name: 'EditingState', optional: true },
    { name: 'Appointments', optional: true },
    { name: 'AppointmentTooltip', optional: true },
];
var AppointmentFormBase = /*#__PURE__*/ (function (_super) {
    __extends(AppointmentFormBase, _super);
    function AppointmentFormBase(props) {
        var _this = _super.call(this, props) || this;
        _this.state = {
            visible: props.visible,
            appointmentData: props.appointmentData || {},
        };
        var stateHelper = createStateHelper(_this, {
            visible: function () {
                var onVisibilityChange = _this.props.onVisibilityChange;
                return onVisibilityChange;
            },
            appointmentData: function () {
                var onAppointmentDataChange = _this.props.onAppointmentDataChange;
                return onAppointmentDataChange;
            },
        });
        var toggleVisibility = function () {
            var isOpen = _this.state.visible;
            return !isOpen;
        };
        _this.toggleVisibility = stateHelper.applyFieldReducer
            .bind(stateHelper, 'visible', toggleVisibility);
        _this.setAppointmentData = stateHelper.applyFieldReducer
            .bind(stateHelper, 'appointmentData', setAppointmentData);
        _this.openFormHandler = function (appointmentData) {
            _this.setAppointmentData({ appointmentData: appointmentData });
            _this.toggleVisibility();
        };
        return _this;
    }
    AppointmentFormBase.getDerivedStateFromProps = function (nextProps, prevState) {
        var _a = nextProps.visible, visible = _a === void 0 ? prevState.visible : _a, _b = nextProps.appointmentData, appointmentData = _b === void 0 ? prevState.appointmentData : _b;
        return {
            appointmentData: appointmentData,
            visible: visible,
        };
    };
    AppointmentFormBase.prototype.render = function () {
        var _this = this;
        var _a = this.props, AllDayEditor = _a.allDayComponent, Container = _a.containerComponent, ScrollableArea = _a.scrollableAreaComponent, StaticArea = _a.staticAreaComponent, Popup = _a.popupComponent, StartDateEditor = _a.startDateComponent, EndDateEditor = _a.endDateComponent, TitleEditor = _a.titleComponent, CommandButton = _a.commandButtonComponent, readOnly = _a.readOnly, messages = _a.messages;
        var _b = this.state, visible = _b.visible, appointmentData = _b.appointmentData;
        var getMessage = getMessagesFormatter(__assign(__assign({}, defaultMessages$1), messages));
        return (createElement(Plugin, { name: "AppointmentForm", dependencies: pluginDependencies$5 },
            createElement(Template, { name: "timeTable" },
                createElement(TemplatePlaceholder, null),
                createElement(TemplateConnector, null, function (_a, _b) {
                    var addedAppointment = _a.addedAppointment, appointmentChanges = _a.appointmentChanges, editingAppointment = _a.editingAppointment;
                    var stopEditAppointment = _b.stopEditAppointment, changeAddedAppointment = _b.changeAddedAppointment, cancelAddedAppointment = _b.cancelAddedAppointment, commitAddedAppointment = _b.commitAddedAppointment, changeAppointment = _b.changeAppointment, cancelChangedAppointment = _b.cancelChangedAppointment, finishCommitAppointment = _b.finishCommitAppointment;
                    var isNew = !editingAppointment;
                    var changedAppointment = __assign(__assign({}, appointmentData), isNew ? addedAppointment : appointmentChanges);
                    var changeAppointmentField = isNew
                        ? changeAddedAppointment
                        : changeAppointment;
                    return (createElement(Popup, { visible: visible },
                        createElement(Container, null,
                            createElement(ScrollableArea, null,
                                createElement(TitleEditor, __assign({ readOnly: readOnly, label: getMessage('titleLabel'), value: changedAppointment.title }, changeAppointment && {
                                    onValueChange: function (title) { return changeAppointmentField({ change: { title: title } }); },
                                })),
                                createElement(StartDateEditor, __assign({ readOnly: readOnly, label: getMessage('startDateLabel'), value: changedAppointment.startDate }, changeAppointment && {
                                    onValueChange: function (startDate) { return changeAppointmentField({ change: { startDate: startDate } }); },
                                })),
                                createElement(EndDateEditor, __assign({ readOnly: readOnly, label: getMessage('endDateLabel'), value: changedAppointment.endDate }, changeAppointment && {
                                    onValueChange: function (endDate) { return changeAppointmentField({ change: { endDate: endDate } }); },
                                })),
                                createElement(AllDayEditor, __assign({ readOnly: readOnly, text: getMessage('allDayLabel'), value: changedAppointment.allDay }, changeAppointment && {
                                    onValueChange: function (allDay) { return changeAppointmentField({ change: { allDay: allDay } }); },
                                }))),
                            createElement(StaticArea, null,
                                createElement(CommandButton, { text: getMessage('cancelCommand'), onExecute: function () {
                                        _this.toggleVisibility();
                                        if (stopEditAppointment) {
                                            if (isNew) {
                                                cancelAddedAppointment();
                                            }
                                            else {
                                                stopEditAppointment();
                                                cancelChangedAppointment();
                                            }
                                        }
                                    }, id: CANCEL_COMMAND_BUTTON }),
                                !readOnly && (createElement(CommandButton, { text: getMessage('commitCommand'), onExecute: function () {
                                        _this.toggleVisibility();
                                        if (finishCommitAppointment) {
                                            if (isNew) {
                                                commitAddedAppointment();
                                            }
                                            else {
                                                finishCommitAppointment();
                                            }
                                        }
                                    }, id: COMMIT_COMMAND_BUTTON }))))));
                })),
            createElement(Template, { name: "tooltip" }, function (params) { return (createElement(TemplateConnector, null, function (getters, _a) {
                var startEditAppointment = _a.startEditAppointment;
                return (createElement(TemplatePlaceholder, { params: __assign(__assign({}, params), { onOpenButtonClick: function () {
                            _this.openFormHandler(params.appointmentMeta.data);
                            callActionIfExists(startEditAppointment, params.appointmentMeta.data);
                        } }) }));
            })); }),
            createElement(Template, { name: "appointment" }, function (params) { return (createElement(TemplateConnector, null, function (getters, _a) {
                var startEditAppointment = _a.startEditAppointment;
                return (createElement(TemplatePlaceholder, { params: __assign(__assign({}, params), { onDoubleClick: function () {
                            _this.openFormHandler(params.data);
                            callActionIfExists(startEditAppointment, params.data);
                        } }) }));
            })); }),
            createElement(Template, { name: "cell" }, function (params) { return (createElement(TemplateConnector, null, function (getters, _a) {
                var addAppointment = _a.addAppointment;
                var newAppointmentData = {
                    title: undefined,
                    startDate: params.startDate,
                    endDate: params.endDate,
                    allDay: isAllDayCell(params.startDate, params.endDate),
                };
                return (createElement(TemplatePlaceholder, { params: __assign(__assign({}, params), { onDoubleClick: function () {
                            _this.openFormHandler(newAppointmentData);
                            callActionIfExists(addAppointment, { appointmentData: newAppointmentData });
                        } }) }));
            })); })));
    };
    AppointmentFormBase.defaultProps = {
        messages: {},
        readOnly: false,
        onVisibilityChange: function () { return undefined; },
        onAppointmentDataChange: function () { return undefined; },
    };
    AppointmentFormBase.components = {
        popupComponent: 'Popup',
        containerComponent: 'Container',
        startDateComponent: 'StartDateEditor',
        endDateComponent: 'EndDateEditor',
        titleComponent: 'TitleEditor',
        allDayComponent: 'AllDayEditor',
        commandButtonComponent: 'CommandButton',
        scrollableAreaComponent: 'ScrollableArea',
        staticAreaComponent: 'StaticArea',
    };
    return AppointmentFormBase;
}(PureComponent));
// tslint:disable-next-line: max-line-length
/** The AppointmentForm plugin renders a form that visualizes appointment’s data and allows a user to modify this data. */
var AppointmentForm = AppointmentFormBase;

var renderAppointmentItems = function (items, formatDate, data, Wrapper, Appointment) { return (items.length > 0 ? (createElement(Wrapper, null, items.map(function (_a, index) {
    var dataItem = _a.dataItem, type = _a.type, fromPrev = _a.fromPrev, toNext = _a.toNext, geometry = __rest(_a, ["dataItem", "type", "fromPrev", "toNext"]);
    return (createElement(Appointment, { key: index.toString(), data: data, style: getAppointmentStyle(geometry), type: type, fromPrev: fromPrev, toNext: toNext, formatDate: formatDate }));
}))) : (null)); };
var pluginDependencies$6 = [
    { name: 'EditingState' },
    { name: 'Appointments' },
    { name: 'EditRecurrenceMenu', optional: true },
    { name: 'IntegratedEditing', optional: true },
    { name: 'DayView', optional: true },
    { name: 'WeekView', optional: true },
    { name: 'MonthView', optional: true },
    { name: 'AllDayPanel', optional: true },
];
var DragDropProviderBase = /*#__PURE__*/ (function (_super) {
    __extends(DragDropProviderBase, _super);
    function DragDropProviderBase() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.timeTableDraftAppointments = [];
        _this.allDayDraftAppointments = [];
        _this.offsetTimeTop = null;
        _this.appointmentStartTime = null;
        _this.appointmentEndTime = null;
        _this.state = {
            startTime: null,
            endTime: null,
            payload: null,
            isOutside: false,
        };
        _this.handleDrop = function (_a) {
            var finishCommitAppointment = _a.finishCommitAppointment;
            return function () {
                finishCommitAppointment();
                _this.resetCache();
            };
        };
        _this.handleLeave = function () {
            _this.setState({ isOutside: true });
        };
        return _this;
    }
    DragDropProviderBase.prototype.onPayloadChange = function (actions) {
        var _this = this;
        return function (args) { return _this.handlePayloadChange(args, actions); };
    };
    DragDropProviderBase.prototype.calculateNextBoundaries = function (getters, actions) {
        var _this = this;
        return function (args) { return _this.calculateBoundaries(args, getters, actions); };
    };
    DragDropProviderBase.prototype.resetCache = function () {
        this.timeTableDraftAppointments = [];
        this.allDayDraftAppointments = [];
        this.offsetTimeTop = null;
        this.appointmentStartTime = null;
        this.appointmentEndTime = null;
        this.setState({
            payload: null,
            startTime: null,
            endTime: null,
            isOutside: false,
        });
    };
    DragDropProviderBase.prototype.applyChanges = function (startTime, endTime, payload, startEditAppointment, changeAppointment) {
        startEditAppointment(payload);
        changeAppointment({
            change: __assign({ startDate: startTime, endDate: endTime }, payload.allDay && { allDay: undefined }),
        });
        this.setState({ startTime: startTime, endTime: endTime, payload: payload, isOutside: false });
    };
    DragDropProviderBase.prototype.handlePayloadChange = function (_a, _b) {
        var payload = _a.payload;
        var finishCommitAppointment = _b.finishCommitAppointment;
        var isOutside = this.state.isOutside;
        if (payload || !isOutside)
            return;
        finishCommitAppointment();
        this.resetCache();
    };
    DragDropProviderBase.prototype.calculateBoundaries = function (_a, _b, _c) {
        var payload = _a.payload, clientOffset = _a.clientOffset;
        var viewCellsData = _b.viewCellsData, startViewDate = _b.startViewDate, endViewDate = _b.endViewDate, excludedDays = _b.excludedDays, timeTableElementsMeta = _b.timeTableElementsMeta, allDayElementsMeta = _b.allDayElementsMeta, scrollingStrategy = _b.scrollingStrategy;
        var changeAppointment = _c.changeAppointment, startEditAppointment = _c.startEditAppointment;
        if (clientOffset) {
            autoScroll(clientOffset, scrollingStrategy);
        }
        var tableCellElementsMeta = timeTableElementsMeta;
        // AllDayPanel doesn't always exist
        var allDayCellsElementsMeta = allDayElementsMeta && allDayElementsMeta.getCellRects
            ? allDayElementsMeta
            : { getCellRects: [] };
        var timeTableIndex = cellIndex(tableCellElementsMeta.getCellRects, clientOffset);
        var allDayIndex = cellIndex(allDayCellsElementsMeta.getCellRects, clientOffset);
        if (allDayIndex === -1 && timeTableIndex === -1)
            return;
        var targetData = cellData(timeTableIndex, allDayIndex, viewCellsData);
        var targetType = cellType(targetData);
        var insidePart = calculateInsidePart(clientOffset.y, tableCellElementsMeta.getCellRects, timeTableIndex);
        var cellDurationMinutes = intervalDuration(targetData, 'minutes');
        var _d = calculateAppointmentTimeBoundaries(payload, targetData, targetType, cellDurationMinutes, insidePart, this.offsetTimeTop), appointmentStartTime = _d.appointmentStartTime, appointmentEndTime = _d.appointmentEndTime, offsetTimeTop = _d.offsetTimeTop;
        this.appointmentStartTime = appointmentStartTime || this.appointmentStartTime;
        this.appointmentEndTime = appointmentEndTime || this.appointmentEndTime;
        this.offsetTimeTop = offsetTimeTop;
        var _e = this.state, startTime = _e.startTime, endTime = _e.endTime;
        if (moment(startTime).isSame(this.appointmentStartTime)
            && moment(endTime).isSame(this.appointmentEndTime))
            return;
        var draftAppointments = [{
                dataItem: __assign(__assign({}, payload), { startDate: this.appointmentStartTime, endDate: this.appointmentEndTime }),
                start: this.appointmentStartTime,
                end: this.appointmentEndTime,
            }];
        var _f = calculateDraftAppointments(allDayIndex, draftAppointments, startViewDate, endViewDate, excludedDays, viewCellsData, allDayCellsElementsMeta, targetType, cellDurationMinutes, tableCellElementsMeta), allDayDraftAppointments = _f.allDayDraftAppointments, timeTableDraftAppointments = _f.timeTableDraftAppointments;
        this.allDayDraftAppointments = allDayDraftAppointments;
        this.timeTableDraftAppointments = timeTableDraftAppointments;
        this.applyChanges(this.appointmentStartTime, this.appointmentEndTime, payload, startEditAppointment, changeAppointment);
    };
    DragDropProviderBase.prototype.render = function () {
        var _this = this;
        var payload = this.state.payload;
        var _a = this.props, Container = _a.containerComponent, DraftAppointment = _a.draftAppointmentComponent, SourceAppointment = _a.sourceAppointmentComponent, Resize = _a.resizeComponent, allowDrag = _a.allowDrag, allowResize = _a.allowResize;
        var draftData = __assign(__assign({}, payload), { startDate: this.appointmentStartTime, endDate: this.appointmentEndTime });
        return (createElement(Plugin, { name: "DragDropProvider", dependencies: pluginDependencies$6 },
            createElement(Template, { name: "body" },
                createElement(TemplateConnector, null, function (_a, _b) {
                    var viewCellsData = _a.viewCellsData, startViewDate = _a.startViewDate, endViewDate = _a.endViewDate, excludedDays = _a.excludedDays, timeTableElementsMeta = _a.timeTableElementsMeta, allDayElementsMeta = _a.allDayElementsMeta, scrollingStrategy = _a.scrollingStrategy;
                    var changeAppointment = _b.changeAppointment, startEditAppointment = _b.startEditAppointment, finishCommitAppointment = _b.finishCommitAppointment;
                    var calculateBoundariesByMove = _this.calculateNextBoundaries({
                        viewCellsData: viewCellsData,
                        startViewDate: startViewDate,
                        endViewDate: endViewDate,
                        excludedDays: excludedDays,
                        timeTableElementsMeta: timeTableElementsMeta,
                        allDayElementsMeta: allDayElementsMeta,
                        scrollingStrategy: scrollingStrategy,
                    }, { changeAppointment: changeAppointment, startEditAppointment: startEditAppointment });
                    return (createElement(DragDropProvider$1, { onChange: _this.onPayloadChange({ finishCommitAppointment: finishCommitAppointment }) },
                        createElement(DropTarget, { onOver: calculateBoundariesByMove, onEnter: calculateBoundariesByMove, onDrop: _this.handleDrop({ finishCommitAppointment: finishCommitAppointment }), onLeave: _this.handleLeave },
                            createElement(TemplatePlaceholder, null))));
                })),
            createElement(Template, { name: "appointmentContent", predicate: function (_a) {
                    var data = _a.data;
                    return allowDrag(data);
                } }, function (_a) {
                var styles = _a.styles, params = __rest(_a, ["styles"]);
                return (createElement(DragSource, { payload: __assign(__assign({}, params.data), { type: params.type }) }, payload && params.data.id === payload.id ? (createElement(SourceAppointment, __assign({}, params))) : (createElement(TemplatePlaceholder, { params: __assign(__assign({}, params), { draggable: true }) }))));
            }),
            createElement(Template, { name: "appointmentTop", predicate: function (params) { return !params.slice && allowResize(params.data); } }, function (_a) {
                var data = _a.data, type = _a.type;
                return (createElement(DragSource, { payload: __assign(__assign({}, data), { type: RESIZE_TOP, appointmentType: type }) },
                    createElement(Resize, { position: POSITION_START, appointmentType: type })));
            }),
            createElement(Template, { name: "appointmentBottom", predicate: function (params) { return !params.slice && allowResize(params.data); } }, function (_a) {
                var data = _a.data, type = _a.type;
                return (createElement(DragSource, { payload: __assign(__assign({}, data), { type: RESIZE_BOTTOM, appointmentType: type }) },
                    createElement(Resize, { position: POSITION_END, appointmentType: type })));
            }),
            createElement(Template, { name: "allDayPanel" },
                createElement(TemplatePlaceholder, null),
                createElement(TemplateConnector, null, function (_a) {
                    var formatDate = _a.formatDate;
                    return renderAppointmentItems(_this.allDayDraftAppointments, formatDate, draftData, Container, DraftAppointment);
                })),
            createElement(Template, { name: "timeTable" },
                createElement(TemplatePlaceholder, null),
                createElement(TemplateConnector, null, function (_a) {
                    var formatDate = _a.formatDate;
                    return renderAppointmentItems(_this.timeTableDraftAppointments, formatDate, draftData, Container, DraftAppointment);
                }))));
    };
    DragDropProviderBase.components = {
        containerComponent: 'Container',
        draftAppointmentComponent: 'DraftAppointment',
        sourceAppointmentComponent: 'SourceAppointment',
        resizeComponent: 'Resize',
    };
    DragDropProviderBase.defaultProps = {
        allowDrag: function () { return true; },
        allowResize: function () { return true; },
    };
    return DragDropProviderBase;
}(PureComponent));
/** A plugin that enables users to edit appointments via drag-and-drop. */
var DragDropProvider = DragDropProviderBase;

var pluginDependencies$7 = [
    { name: 'Toolbar' },
    { name: 'ViewState' },
];
var defaultMessages$2 = {
    today: 'Today',
};
var TodayButtonBase = /*#__PURE__*/ (function (_super) {
    __extends(TodayButtonBase, _super);
    function TodayButtonBase() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    TodayButtonBase.prototype.render = function () {
        var _a = this.props, Button = _a.buttonComponent, messages = _a.messages;
        var getMessage = getMessagesFormatter(__assign(__assign({}, defaultMessages$2), messages));
        return (createElement(Plugin, { name: "TodayButton", dependencies: pluginDependencies$7 },
            createElement(Template, { name: "toolbarContent" },
                createElement(TemplateConnector, null, function (getters, _a) {
                    var changeCurrentDate = _a.changeCurrentDate;
                    var setCurrentDate = function (nextDate) { return changeCurrentDate({
                        nextDate: nextDate,
                    }); };
                    return (createElement(Button, { getMessage: getMessage, setCurrentDate: setCurrentDate }));
                }),
                createElement(TemplatePlaceholder, null))));
    };
    TodayButtonBase.components = {
        buttonComponent: 'Button',
    };
    return TodayButtonBase;
}(PureComponent));
/** A plugin that renders the Scheduler's button which sets the current date to today's date. */
var TodayButton = TodayButtonBase;

var _a;
var pluginDependencies$8 = [
    { name: 'EditingState' },
];
var defaultAvailableOperations = [
    { value: RECURRENCE_EDIT_SCOPE.CURRENT },
    { value: RECURRENCE_EDIT_SCOPE.CURRENT_AND_FOLLOWING },
    { value: RECURRENCE_EDIT_SCOPE.ALL },
];
var defaultMessages$3 = (_a = {},
    _a[RECURRENCE_EDIT_SCOPE.CURRENT] = 'This appointment',
    _a[RECURRENCE_EDIT_SCOPE.CURRENT_AND_FOLLOWING] = 'This and following appointments',
    _a[RECURRENCE_EDIT_SCOPE.ALL] = 'All appointments',
    _a.menuEditTitle = 'Edit recurring appointment',
    _a.menuDeleteTitle = 'Delete recurring appointment',
    _a.cancelButton = 'Cancel',
    _a.commitButton = 'OK',
    _a);
var EditRecurrenceMenuBase = /*#__PURE__*/ (function (_super) {
    __extends(EditRecurrenceMenuBase, _super);
    function EditRecurrenceMenuBase() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.modalContainer = createRef();
        _this.state = {
            isOpen: false,
            deletedAppointmentData: null,
        };
        _this.finishCommitAppointment = function (payload, _a, _b) {
            var editingAppointment = _a.editingAppointment;
            var commitChangedAppointment = _b.commitChangedAppointment;
            if (editingAppointment && !editingAppointment.rRule) {
                commitChangedAppointment();
            }
            else {
                _this.setState({
                    isOpen: true, deletedAppointmentData: null,
                });
            }
        };
        _this.finishDeleteAppointment = function (payload, getters, _a) {
            var commitDeletedAppointment = _a.commitDeletedAppointment;
            if (payload && !payload.rRule) {
                commitDeletedAppointment({ deletedAppointmentData: payload });
            }
            else {
                _this.setState({
                    isOpen: true, deletedAppointmentData: payload,
                });
            }
        };
        _this.commit = memoize(function (editAction, deleteAction, payload) { return function (type) {
            if (payload) {
                deleteAction({ deletedAppointmentData: payload, type: type });
            }
            else {
                editAction(type);
            }
            _this.closeMenu();
        }; });
        _this.closeMenu = function () {
            _this.setState({ isOpen: false, deletedAppointmentData: null });
        };
        _this.cancelEditing = memoize(function (cancelAction, stopEditAction) { return function () {
            stopEditAction();
            cancelAction();
            _this.closeMenu();
        }; });
        _this.availableOperations = memoize(function (getMessage, menuAvailableOperations) {
            return menuAvailableOperations.map(function (_a) {
                var value = _a.value;
                return ({
                    value: value,
                    title: getMessage([value]),
                });
            });
        });
        _this.getMessage = memoize(function (messages, menuMessages) {
            return getMessagesFormatter(__assign(__assign({}, menuMessages), messages));
        });
        return _this;
    }
    EditRecurrenceMenuBase.prototype.render = function () {
        var _this = this;
        var _a = this.state, isOpen = _a.isOpen, deletedAppointmentData = _a.deletedAppointmentData;
        var _b = this.props, Layout = _b.layoutComponent, Overlay = _b.overlayComponent, Container = _b.containerComponent, buttonComponent = _b.buttonComponent, messages = _b.messages;
        var getMessage = this.getMessage(messages, defaultMessages$3);
        var availableOperations = this.availableOperations(getMessage, defaultAvailableOperations);
        return (createElement(Plugin, { name: "EditRecurrenceMenu", dependencies: pluginDependencies$8 },
            createElement(Action, { name: "finishCommitAppointment", action: this.finishCommitAppointment }),
            createElement(Action, { name: "finishDeleteAppointment", action: this.finishDeleteAppointment }),
            createElement(Template, { name: "schedulerRoot" },
                createElement(TemplatePlaceholder, null),
                createElement(Container, { ref: this.modalContainer }),
                createElement(TemplatePlaceholder, { name: "overlay" })),
            createElement(Template, { name: "overlay" },
                createElement(TemplateConnector, null, function (getters, _a) {
                    var commitChangedAppointment = _a.commitChangedAppointment, commitDeletedAppointment = _a.commitDeletedAppointment, cancelChangedAppointment = _a.cancelChangedAppointment, stopEditAppointment = _a.stopEditAppointment;
                    var commit = _this.commit(commitChangedAppointment, commitDeletedAppointment, deletedAppointmentData);
                    var cancelEditing = _this.cancelEditing(cancelChangedAppointment, stopEditAppointment);
                    return (createElement(Overlay, { target: _this.modalContainer, visible: isOpen, onHide: _this.closeMenu },
                        createElement(Layout, { isDeleting: !!deletedAppointmentData, buttonComponent: buttonComponent, handleClose: cancelEditing, commit: commit, availableOperations: availableOperations, getMessage: getMessage })));
                }))));
    };
    EditRecurrenceMenuBase.components = {
        layoutComponent: 'Layout',
        overlayComponent: 'Overlay',
        buttonComponent: 'Button',
        containerComponent: 'Container',
    };
    return EditRecurrenceMenuBase;
}(PureComponent));
/**
 * A plugin that renders the Scheduler's edit menu.
 * Should not be used with the `IntegratedEditing` plugin.
 */
var EditRecurrenceMenu = EditRecurrenceMenuBase;

var pluginDependencies$9 = [
    { name: 'EditingState' },
];
var IntegratedEditingBase = /*#__PURE__*/ (function (_super) {
    __extends(IntegratedEditingBase, _super);
    function IntegratedEditingBase() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.finishCommitAppointment = function (payload, getters, _a) {
            var commitChangedAppointment = _a.commitChangedAppointment;
            commitChangedAppointment();
        };
        _this.finishDeleteAppointment = function (payload, getters, _a) {
            var commitDeletedAppointment = _a.commitDeletedAppointment;
            commitDeletedAppointment({ deletedAppointmentData: payload });
        };
        return _this;
    }
    IntegratedEditingBase.prototype.render = function () {
        return (createElement(Plugin, { name: "IntegratedEditing", dependencies: pluginDependencies$9 },
            createElement(Action, { name: "finishCommitAppointment", action: this.finishCommitAppointment }),
            createElement(Action, { name: "finishDeleteAppointment", action: this.finishDeleteAppointment })));
    };
    IntegratedEditingBase.defaultProps = {
        totalCount: 0,
    };
    return IntegratedEditingBase;
}(PureComponent));
/** A plugin that allows implementing a editing calculation logic. */
var IntegratedEditing = IntegratedEditingBase;

export { AllDayPanel, AppointmentForm, AppointmentTooltip, Appointments, DateNavigator, DayView, DragDropProvider, EditRecurrenceMenu, EditingState, IntegratedEditing, MonthView, Scheduler, TodayButton, Toolbar, ViewState, ViewSwitcher, WeekView };
//# sourceMappingURL=dx-react-scheduler.es.js.map
